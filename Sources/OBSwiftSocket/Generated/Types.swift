//
//  Protocol.swift
//  OBSwiftSocket
//
//  Generated by script on 10/1/22.
//  Script written by Edon Valdman
//

import Foundation
import JSONValue

// MARK: - Enums

public enum OBSEnums {
    public struct EventSubscription: OptionSet, Codable {
        public let rawValue: Int
        public init(rawValue: Int) {
            self.rawValue = rawValue
        }

        /// Subcription value used to disable all events.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let none = 0

        /// Subscription value to receive events in the `General` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let general = EventSubscription(rawValue: 1 << 0)

        /// Subscription value to receive events in the `Config` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let config = EventSubscription(rawValue: 1 << 1)

        /// Subscription value to receive events in the `Scenes` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let scenes = EventSubscription(rawValue: 1 << 2)

        /// Subscription value to receive events in the `Inputs` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let inputs = EventSubscription(rawValue: 1 << 3)

        /// Subscription value to receive events in the `Transitions` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let transitions = EventSubscription(rawValue: 1 << 4)

        /// Subscription value to receive events in the `Filters` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let filters = EventSubscription(rawValue: 1 << 5)

        /// Subscription value to receive events in the `Outputs` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let outputs = EventSubscription(rawValue: 1 << 6)

        /// Subscription value to receive events in the `SceneItems` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let sceneItems = EventSubscription(rawValue: 1 << 7)

        /// Subscription value to receive events in the `MediaInputs` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let mediaInputs = EventSubscription(rawValue: 1 << 8)

        /// Subscription value to receive the `VendorEvent` event.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let vendors = EventSubscription(rawValue: 1 << 9)

        /// Subscription value to receive events in the `Ui` category.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let ui = EventSubscription(rawValue: 1 << 10)

        /// Helper to receive all non-high-volume events.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let all: EventSubscription = [.general, .config, .scenes, .inputs, .transitions, .filters, .outputs, .sceneItems, .mediaInputs, .vendors, .ui]

        /// Subscription value to receive the `InputVolumeMeters` high-volume event.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let inputVolumeMeters = EventSubscription(rawValue: 1 << 16)

        /// Subscription value to receive the `InputActiveStateChanged` high-volume event.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let inputActiveStateChanged = EventSubscription(rawValue: 1 << 17)

        /// Subscription value to receive the `InputShowStateChanged` high-volume event.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let inputShowStateChanged = EventSubscription(rawValue: 1 << 18)

        /// Subscription value to receive the `SceneItemTransformChanged` high-volume event.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        public static let sceneItemTransformChanged = EventSubscription(rawValue: 1 << 19)
    }

    public enum RequestBatchExecutionType: Int, Codable {
        /// Not a request batch.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case none = -1

        /// A request batch which processes all requests serially, as fast as possible.
        /// - Note: To introduce artificial delay, use the `Sleep` request and the `sleepMillis` request field.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case serialRealtime = 0

        /// A request batch type which processes all requests serially, in sync with the graphics thread. Designed to provide high accuracy for animations.
        /// - Note: To introduce artificial delay, use the `Sleep` request and the `sleepFrames` request field.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case serialFrame = 1

        /// A request batch type which processes all requests using all available threads in the thread pool.
        /// - Note: This is mainly experimental, and only really shows its colors during requests which require lots of
        /// active processing, like `GetSourceScreenshot`.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case parallel = 2
    }

    public enum RequestStatus: Int, Codable {
        /// Unknown status, should never be used.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case unknown = 0

        /// For internal use to signify a successful field check.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case noError = 10

        /// The request has succeeded.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case success = 100

        /// The `requestType` field is missing from the request data.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case missingType = 203

        /// The request type is invalid or does not exist.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case unknownType = 204

        /// Generic error code.
        /// - Note: A comment is required to be provided by obs-websocket.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case genericError = 205

        /// The request batch execution type is not supported.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case unsupportedBatchExecutionType = 206

        /// A required request field is missing.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case missingField = 300

        /// The request does not have a valid requestData object.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case missingData = 301

        /// Generic invalid request field message.
        /// - Note: A comment is required to be provided by obs-websocket.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidField = 400

        /// A request field has the wrong data type.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidFieldType = 401

        /// A request field (number) is outside of the allowed range.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case fieldOutOfRange = 402

        /// A request field (string or array) is empty and cannot be.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case fieldEmpty = 403

        /// There are too many request fields (eg. a request takes two optionals, where only one is allowed at a time).
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case tooManyFields = 404

        /// An output is running and cannot be in order to perform the request.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case outputRunning = 500

        /// An output is not running and should be.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case outputNotRunning = 501

        /// An output is paused and should not be.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case outputPaused = 502

        /// An output is not paused and should be.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case outputNotPaused = 503

        /// An output is disabled and should not be.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case outputDisabled = 504

        /// Studio mode is active and cannot be.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case studioModeActive = 505

        /// Studio mode is not active and should be.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case studioModeNotActive = 506

        /// The resource was not found.
        /// - Note: Resources are any kind of object in obs-websocket, like inputs, profiles, outputs, etc.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case resourceNotFound = 600

        /// The resource already exists.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case resourceAlreadyExists = 601

        /// The type of resource found is invalid.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidResourceType = 602

        /// There are not enough instances of the resource in order to perform the request.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case notEnoughResources = 603

        /// The state of the resource is invalid. For example, if the resource is blocked from being accessed.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidResourceState = 604

        /// The specified input (obs_source_t-OBS_SOURCE_TYPE_INPUT) had the wrong kind.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidInputKind = 605

        /// The resource does not support being configured.
        /// This is particularly relevant to transitions, where they do not always have changeable settings.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case resourceNotConfigurable = 606

        /// The specified filter (obs_source_t-OBS_SOURCE_TYPE_FILTER) had the wrong kind.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidFilterKind = 607

        /// Creating the resource failed.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case resourceCreationFailed = 700

        /// Performing an action on the resource failed.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case resourceActionFailed = 701

        /// Processing the request failed unexpectedly.
        /// - Note: A comment is required to be provided by obs-websocket.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case processingFailed = 702

        /// The combination of request fields cannot be used to perform an action.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case cannotAct = 703
    }

    public enum MediaInputAction: String, Codable {
        /// No action.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case none = "OBS_WEBSOCKET_MEDIA_INPUT_ACTION_NONE"

        /// Play the media input.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case play = "OBS_WEBSOCKET_MEDIA_INPUT_ACTION_PLAY"

        /// Pause the media input.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case pause = "OBS_WEBSOCKET_MEDIA_INPUT_ACTION_PAUSE"

        /// Stop the media input.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case stop = "OBS_WEBSOCKET_MEDIA_INPUT_ACTION_STOP"

        /// Restart the media input.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case restart = "OBS_WEBSOCKET_MEDIA_INPUT_ACTION_RESTART"

        /// Go to the next playlist item.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case next = "OBS_WEBSOCKET_MEDIA_INPUT_ACTION_NEXT"

        /// Go to the previous playlist item.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case previous = "OBS_WEBSOCKET_MEDIA_INPUT_ACTION_PREVIOUS"
    }

    public enum CloseCode: Int, Codable {
        /// For internal use only to tell the request handler not to perform any close action.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case dont = 0

        /// Unknown reason, should never be used.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case unknownReason = 4000

        /// The server was unable to decode the incoming websocket message.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case messageDeError = 4002

        /// A data field is required but missing from the payload.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case missingDataField = 4003

        /// A data field's value type is invalid.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidDataFieldType = 4004

        /// A data field's value is invalid.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case invalidDataFieldValue = 4005

        /// The specified `op` was invalid or missing.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case unknownOp = 4006

        /// The client sent a websocket message without first sending `Identify` message.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case notIdentified = 4007

        /// The client sent an `Identify` message while already identified.
        /// - Note: Once a client has identified, only `Reidentify` may be used to change session parameters.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case alreadyIdentified = 4008

        /// The authentication attempt (via `Identify`) failed.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case authenticationFailed = 4009

        /// The server detected the usage of an old version of the obs-websocket RPC protocol.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case unsupportedRpcVersion = 4010

        /// The websocket session has been invalidated by the obs-websocket server.
        /// - Note: This is the code used by the `Kick` button in the UI Session List. If you receive this code, you must not automatically reconnect.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case sessionInvalidated = 4011

        /// A requested feature is not supported due to hardware/software limitations.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case unsupportedFeature = 4012
    }

    public enum OpCode: Int, Codable {
        /// The initial message sent by obs-websocket to newly connected clients.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case hello = 0

        /// The message sent by a newly connected client to obs-websocket in response to a `Hello`.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case identify = 1

        /// The response sent by obs-websocket to a client after it has successfully identified with obs-websocket.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case identified = 2

        /// The message sent by an already-identified client to update identification parameters.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case reidentify = 3

        /// The message sent by obs-websocket containing an event payload.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case event = 5

        /// The message sent by a client to obs-websocket to perform a request.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case request = 6

        /// The message sent by obs-websocket in response to a particular request from a client.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case requestResponse = 7

        /// The message sent by a client to obs-websocket to perform a batch of requests.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case requestBatch = 8

        /// The message sent by obs-websocket in response to a particular batch of requests from a client.
        /// - Version: Latest Supported RPC Version - `1`
        /// - Since: Added in v5.0.0
        case requestBatchResponse = 9
    }
}

// MARK: - Requests

public enum OBSRequests {
    public struct EmptyResponse: OBSRequestResponse {}
    public typealias FailedReqResponse = OpDataTypes.RequestResponse
    public typealias FailedBatchReqResponse = OpDataTypes.RequestBatchResponse.Response

    /// Gets the value of a "slot" from the selected persistent data realm.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetPersistentData: OBSRequest {
        public typealias ResponseType = Response

        /// The data realm to select. `OBS_WEBSOCKET_DATA_REALM_GLOBAL` or `OBS_WEBSOCKET_DATA_REALM_PROFILE`
        public var realm: String

        /// The name of the slot to retrieve data from
        public var slotName: String

        public init(realm: String, slotName: String) {
            self.realm = realm
            self.slotName = slotName
        }

        public struct Response: OBSRequestResponse {
            /// Value associated with the slot. `nil` if not set
            public var slotValue: JSONValue?
        }
    }

    /// Sets the value of a "slot" from the selected persistent data realm.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetPersistentData: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// The data realm to select. `OBS_WEBSOCKET_DATA_REALM_GLOBAL` or `OBS_WEBSOCKET_DATA_REALM_PROFILE`
        public var realm: String

        /// The name of the slot to retrieve data from
        public var slotName: String

        /// The value to apply to the slot
        public var slotValue: JSONValue

        public init(realm: String, slotName: String, slotValue: JSONValue) {
            self.realm = realm
            self.slotName = slotName
            self.slotValue = slotValue
        }
    }

    /// Gets an array of all scene collections
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneCollectionList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// The name of the current scene collection
            public var currentSceneCollectionName: String

            /// Array of all available scene collections
            public var sceneCollections: [String]
        }
    }

    /// Switches to a scene collection.
    /// - Note: This will block until the collection has finished changing.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetCurrentSceneCollection: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene collection to switch to
        public var sceneCollectionName: String

        public init(sceneCollectionName: String) {
            self.sceneCollectionName = sceneCollectionName
        }
    }

    /// Creates a new scene collection, switching to it in the process.
    /// - Note: This will block until the collection has finished changing.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CreateSceneCollection: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name for the new scene collection
        public var sceneCollectionName: String

        public init(sceneCollectionName: String) {
            self.sceneCollectionName = sceneCollectionName
        }
    }

    /// Gets an array of all profiles
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetProfileList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// The name of the current profile
            public var currentProfileName: String

            /// Array of all available profiles
            public var profiles: [String]
        }
    }

    /// Switches to a profile.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetCurrentProfile: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the profile to switch to
        public var profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }
    }

    /// Creates a new profile, switching to it in the process
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CreateProfile: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name for the new profile
        public var profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }
    }

    /// Removes a profile. If the current profile is chosen, it will change to a different profile first.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct RemoveProfile: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the profile to remove
        public var profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }
    }

    /// Gets a parameter from the current profile's configuration.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetProfileParameter: OBSRequest {
        public typealias ResponseType = Response

        /// Category of the parameter to get
        public var parameterCategory: String

        /// Name of the parameter to get
        public var parameterName: String

        public init(parameterCategory: String, parameterName: String) {
            self.parameterCategory = parameterCategory
            self.parameterName = parameterName
        }

        public struct Response: OBSRequestResponse {
            /// Value associated with the parameter. `nil` if not set and no default
            public var parameterValue: String?

            /// Default value associated with the parameter. `nil` if no default
            public var defaultParameterValue: String?
        }
    }

    /// Sets the value of a parameter in the current profile's configuration.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetProfileParameter: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Category of the parameter to set
        public var parameterCategory: String

        /// Name of the parameter to set
        public var parameterName: String

        /// Value of the parameter to set. Use `null` to delete
        public var parameterValue: String?

        public init(parameterCategory: String, parameterName: String, parameterValue: String?) {
            self.parameterCategory = parameterCategory
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

    /// Gets the current video settings.
    /// - Note: To get the true FPS value, divide the FPS numerator by the FPS denominator. Example: `60000/1001`
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetVideoSettings: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Numerator of the fractional FPS value
            public var fpsNumerator: Int

            /// Denominator of the fractional FPS value
            public var fpsDenominator: Int

            /// Width of the base (canvas) resolution in pixels
            public var baseWidth: Int

            /// Height of the base (canvas) resolution in pixels
            public var baseHeight: Int

            /// Width of the output resolution in pixels
            public var outputWidth: Int

            /// Height of the output resolution in pixels
            public var outputHeight: Int
        }
    }

    /// Sets the current video settings.
    /// - Note: Fields must be specified in pairs. For example, you cannot set only `baseWidth` without needing to specify `baseHeight`.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetVideoSettings: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Numerator of the fractional FPS value
        /// - Requires: Value Restrictions - `>= 1`
        /// - Important: Optional Behavior - `Not changed`
        public var fpsNumerator: Int?

        /// Denominator of the fractional FPS value
        /// - Requires: Value Restrictions - `>= 1`
        /// - Important: Optional Behavior - `Not changed`
        public var fpsDenominator: Int?

        /// Width of the base (canvas) resolution in pixels
        /// - Requires: Value Restrictions - `>= 1, <= 4096`
        /// - Important: Optional Behavior - `Not changed`
        public var baseWidth: Int?

        /// Height of the base (canvas) resolution in pixels
        /// - Requires: Value Restrictions - `>= 1, <= 4096`
        /// - Important: Optional Behavior - `Not changed`
        public var baseHeight: Int?

        /// Width of the output resolution in pixels
        /// - Requires: Value Restrictions - `>= 1, <= 4096`
        /// - Important: Optional Behavior - `Not changed`
        public var outputWidth: Int?

        /// Height of the output resolution in pixels
        /// - Requires: Value Restrictions - `>= 1, <= 4096`
        /// - Important: Optional Behavior - `Not changed`
        public var outputHeight: Int?

        public init(fpsNumerator: Int?, fpsDenominator: Int?, baseWidth: Int?, baseHeight: Int?, outputWidth: Int?, outputHeight: Int?) {
            self.fpsNumerator = fpsNumerator
            self.fpsDenominator = fpsDenominator
            self.baseWidth = baseWidth
            self.baseHeight = baseHeight
            self.outputWidth = outputWidth
            self.outputHeight = outputHeight
        }

        enum CodingKeys: String, CodingKey {
            case fpsNumerator, fpsDenominator, baseWidth, baseHeight, outputWidth, outputHeight
        }
    }

    /// Gets the current stream service settings (stream destination).
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetStreamServiceSettings: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Stream service type, like `rtmp_custom` or `rtmp_common`
            public var streamServiceType: String

            /// Stream service settings
            public var streamServiceSettings: JSONValue
        }
    }

    /// Sets the current stream service settings (stream destination).
    /// - Note: Simple RTMP settings can be set with type `rtmp_custom` and the settings fields `server` and `key`.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetStreamServiceSettings: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Type of stream service to apply. Example: `rtmp_common` or `rtmp_custom`
        public var streamServiceType: String

        /// Settings to apply to the service
        public var streamServiceSettings: JSONValue

        public init(streamServiceType: String, streamServiceSettings: JSONValue) {
            self.streamServiceType = streamServiceType
            self.streamServiceSettings = streamServiceSettings
        }
    }

    /// Gets the current directory that the record output is set to.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetRecordDirectory: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Output directory
            public var recordDirectory: String
        }
    }

    /// Gets an array of all of a source's filters.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSourceFilterList: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the source
        public var sourceName: String

        public init(sourceName: String) {
            self.sourceName = sourceName
        }

        public struct Response: OBSRequestResponse {
            /// Array of filters
            public var filters: [JSONValue]
        }
    }

    /// Gets the default settings for a filter kind.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSourceFilterDefaultSettings: OBSRequest {
        public typealias ResponseType = Response

        /// Filter kind to get the default settings for
        public var filterKind: String

        public init(filterKind: String) {
            self.filterKind = filterKind
        }

        public struct Response: OBSRequestResponse {
            /// Object of default settings for the filter kind
            public var defaultFilterSettings: JSONValue
        }
    }

    /// Creates a new filter, adding it to the specified source.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CreateSourceFilter: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the source to add the filter to
        public var sourceName: String

        /// Name of the new filter to be created
        public var filterName: String

        /// The kind of filter to be created
        public var filterKind: String

        /// Settings object to initialize the filter with
        /// - Important: Optional Behavior - `Default settings used`
        public var filterSettings: JSONValue?

        public init(sourceName: String, filterName: String, filterKind: String, filterSettings: JSONValue?) {
            self.sourceName = sourceName
            self.filterName = filterName
            self.filterKind = filterKind
            self.filterSettings = filterSettings
        }

        enum CodingKeys: String, CodingKey {
            case sourceName, filterName, filterKind, filterSettings
        }
    }

    /// Removes a filter from a source.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct RemoveSourceFilter: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the source the filter is on
        public var sourceName: String

        /// Name of the filter to remove
        public var filterName: String

        public init(sourceName: String, filterName: String) {
            self.sourceName = sourceName
            self.filterName = filterName
        }
    }

    /// Sets the name of a source filter (rename).
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSourceFilterName: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the source the filter is on
        public var sourceName: String

        /// Current name of the filter
        public var filterName: String

        /// New name for the filter
        public var newFilterName: String

        public init(sourceName: String, filterName: String, newFilterName: String) {
            self.sourceName = sourceName
            self.filterName = filterName
            self.newFilterName = newFilterName
        }
    }

    /// Gets the info for a specific source filter.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSourceFilter: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the source
        public var sourceName: String

        /// Name of the filter
        public var filterName: String

        public init(sourceName: String, filterName: String) {
            self.sourceName = sourceName
            self.filterName = filterName
        }

        public struct Response: OBSRequestResponse {
            /// Whether the filter is enabled
            public var filterEnabled: Bool

            /// Index of the filter in the list, beginning at 0
            public var filterIndex: Int

            /// The kind of filter
            public var filterKind: String

            /// Settings object associated with the filter
            public var filterSettings: JSONValue
        }
    }

    /// Sets the index position of a filter on a source.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSourceFilterIndex: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the source the filter is on
        public var sourceName: String

        /// Name of the filter
        public var filterName: String

        /// New index position of the filter
        /// - Requires: Value Restrictions - `>= 0`
        public var filterIndex: Int

        public init(sourceName: String, filterName: String, filterIndex: Int) {
            self.sourceName = sourceName
            self.filterName = filterName
            self.filterIndex = filterIndex
        }
    }

    /// Sets the settings of a source filter.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSourceFilterSettings: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the source the filter is on
        public var sourceName: String

        /// Name of the filter to set the settings of
        public var filterName: String

        /// Object of settings to apply
        public var filterSettings: JSONValue

        /// True == apply the settings on top of existing ones, False == reset the input to its defaults, then apply settings.
        /// - Important: Optional Behavior - `true`
        public var overlay: Bool?

        public init(sourceName: String, filterName: String, filterSettings: JSONValue, overlay: Bool?) {
            self.sourceName = sourceName
            self.filterName = filterName
            self.filterSettings = filterSettings
            self.overlay = overlay
        }

        enum CodingKeys: String, CodingKey {
            case sourceName, filterName, filterSettings, overlay
        }
    }

    /// Sets the enable state of a source filter.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSourceFilterEnabled: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the source the filter is on
        public var sourceName: String

        /// Name of the filter
        public var filterName: String

        /// New enable state of the filter
        public var filterEnabled: Bool

        public init(sourceName: String, filterName: String, filterEnabled: Bool) {
            self.sourceName = sourceName
            self.filterName = filterName
            self.filterEnabled = filterEnabled
        }
    }

    /// Gets data about the current plugin and RPC version.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetVersion: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Current OBS Studio version
            public var obsVersion: String

            /// Current obs-websocket version
            public var obsWebSocketVersion: String

            /// Current latest obs-websocket RPC version
            public var rpcVersion: Int

            /// Array of available RPC requests for the currently negotiated RPC version
            public var availableRequests: [String]

            /// Image formats available in `GetSourceScreenshot` and `SaveSourceScreenshot` requests.
            public var supportedImageFormats: [String]

            /// Name of the platform. Usually `windows`, `macos`, or `ubuntu` (linux flavor). Not guaranteed to be any of those
            public var platform: String

            /// Description of the platform, like `Windows 10 (10.0)`
            public var platformDescription: String
        }
    }

    /// Gets statistics about OBS, obs-websocket, and the current session.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetStats: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Current CPU usage in percent
            public var cpuUsage: Float

            /// Amount of memory in MB currently being used by OBS
            public var memoryUsage: Float

            /// Available disk space on the device being used for recording storage
            public var availableDiskSpace: Float

            /// Current FPS being rendered
            public var activeFps: Float

            /// Average time in milliseconds that OBS is taking to render a frame
            public var averageFrameRenderTime: Float

            /// Number of frames skipped by OBS in the render thread
            public var renderSkippedFrames: Int

            /// Total number of frames outputted by the render thread
            public var renderTotalFrames: Int

            /// Number of frames skipped by OBS in the output thread
            public var outputSkippedFrames: Int

            /// Total number of frames outputted by the output thread
            public var outputTotalFrames: Int

            /// Total number of messages received by obs-websocket from the client
            public var webSocketSessionIncomingMessages: Int

            /// Total number of messages sent by obs-websocket to the client
            public var webSocketSessionOutgoingMessages: Int
        }
    }

    /// Broadcasts a `CustomEvent` to all WebSocket clients. Receivers are clients which are identified and subscribed.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct BroadcastCustomEvent: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Data payload to emit to all receivers
        public var eventData: JSONValue

        public init(eventData: JSONValue) {
            self.eventData = eventData
        }
    }

    /// Call a request registered to a vendor.
    ///
    /// A vendor is a unique name registered by a third-party plugin or script, which allows for custom requests and events to be added to obs-websocket.
    ///
    /// If a plugin or script implements vendor requests or events, documentation is expected to be provided with them.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CallVendorRequest: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the vendor to use
        public var vendorName: String

        /// The request type to call
        public var requestType: String

        /// Object containing appropriate request data
        /// - Important: Optional Behavior - `{}`
        public var requestData: JSONValue?

        public init(vendorName: String, requestType: String, requestData: JSONValue?) {
            self.vendorName = vendorName
            self.requestType = requestType
            self.requestData = requestData
        }

        public struct Response: OBSRequestResponse {
            /// Echoed of `vendorName`
            public var vendorName: String

            /// Echoed of `requestType`
            public var requestType: String

            /// Object containing appropriate response data. {} if request does not provide any response data
            public var responseData: JSONValue
        }

        enum CodingKeys: String, CodingKey {
            case vendorName, requestType, requestData
        }
    }

    /// Gets an array of all hotkey names in OBS
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetHotkeyList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Array of hotkey names
            public var hotkeys: [String]
        }
    }

    /// Triggers a hotkey using its name. See `GetHotkeyList`
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct TriggerHotkeyByName: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the hotkey to trigger
        public var hotkeyName: String

        public init(hotkeyName: String) {
            self.hotkeyName = hotkeyName
        }
    }

    /// Triggers a hotkey using a sequence of keys.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct TriggerHotkeyByKeySequence: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// The OBS key ID to use. See https://github.com/obsproject/obs-studio/blob/master/libobs/obs-hotkeys.h
        public var keyId: String

        /// Object containing key modifiers to apply
        public var keyModifiers: KeyModifiers

        public init(keyId: String, keyModifiers: KeyModifiers) {
            self.keyId = keyId
            self.keyModifiers = keyModifiers
        }

        public struct KeyModifiers: Codable {
            /// Press Shift
            public var shift: Bool

            /// Press CTRL
            public var control: Bool

            /// Press ALT
            public var alt: Bool

            /// Press CMD (Mac)
            public var command: Bool

            public init(shift: Bool, control: Bool, alt: Bool, command: Bool) {
                self.shift = shift
                self.control = control
                self.alt = alt
                self.command = command
            }
        }
    }

    /// Sleeps for a time duration or number of frames. Only available in request batches with types `SERIAL_REALTIME` or `SERIAL_FRAME`.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct Sleep: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Number of milliseconds to sleep for (if `SERIAL_REALTIME` mode)
        /// - Requires: Value Restrictions - `>= 0, <= 50000`
        public var sleepMillis: Int

        /// Number of frames to sleep for (if `SERIAL_FRAME` mode)
        /// - Requires: Value Restrictions - `>= 0, <= 10000`
        public var sleepFrames: Int

        public init(sleepMillis: Int, sleepFrames: Int) {
            self.sleepMillis = sleepMillis
            self.sleepFrames = sleepFrames
        }
    }

    /// Gets an array of all inputs in OBS.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputList: OBSRequest {
        public typealias ResponseType = Response

        /// Restrict the array to only inputs of the specified kind
        /// - Important: Optional Behavior - `All kinds included`
        public var inputKind: String?

        public init(inputKind: String?) {
            self.inputKind = inputKind
        }

        public struct Response: OBSRequestResponse {
            /// Array of inputs
            public var inputs: [JSONValue]
        }

        enum CodingKeys: String, CodingKey {
            case inputKind
        }
    }

    /// Gets an array of all available input kinds in OBS.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputKindList: OBSRequest {
        public typealias ResponseType = Response

        /// True == Return all kinds as unversioned, False == Return with version suffixes (if available)
        /// - Important: Optional Behavior - `false`
        public var unversioned: Bool?

        public init(unversioned: Bool?) {
            self.unversioned = unversioned
        }

        public struct Response: OBSRequestResponse {
            /// Array of input kinds
            public var inputKinds: [String]
        }

        enum CodingKeys: String, CodingKey {
            case unversioned
        }
    }

    /// Gets the names of all special inputs.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSpecialInputs: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Name of the Desktop Audio input
            public var desktop1: String

            /// Name of the Desktop Audio 2 input
            public var desktop2: String

            /// Name of the Mic/Auxiliary Audio input
            public var mic1: String

            /// Name of the Mic/Auxiliary Audio 2 input
            public var mic2: String

            /// Name of the Mic/Auxiliary Audio 3 input
            public var mic3: String

            /// Name of the Mic/Auxiliary Audio 4 input
            public var mic4: String
        }
    }

    /// Creates a new input, adding it as a scene item to the specified scene.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CreateInput: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene to add the input to as a scene item
        public var sceneName: String

        /// Name of the new input to created
        public var inputName: String

        /// The kind of input to be created
        public var inputKind: String

        /// Settings object to initialize the input with
        /// - Important: Optional Behavior - `Default settings used`
        public var inputSettings: JSONValue?

        /// Whether to set the created scene item to enabled or disabled
        /// - Important: Optional Behavior - `True`
        public var sceneItemEnabled: Bool?

        public init(sceneName: String, inputName: String, inputKind: String, inputSettings: JSONValue?, sceneItemEnabled: Bool?) {
            self.sceneName = sceneName
            self.inputName = inputName
            self.inputKind = inputKind
            self.inputSettings = inputSettings
            self.sceneItemEnabled = sceneItemEnabled
        }

        public struct Response: OBSRequestResponse {
            /// ID of the newly created scene item
            public var sceneItemId: Int
        }

        enum CodingKeys: String, CodingKey {
            case sceneName, inputName, inputKind, inputSettings, sceneItemEnabled
        }
    }

    /// Removes an existing input.
    /// - Note: Will immediately remove all associated scene items.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct RemoveInput: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to remove
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }
    }

    /// Sets the name of an input (rename).
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputName: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Current input name
        public var inputName: String

        /// New name for the input
        public var newInputName: String

        public init(inputName: String, newInputName: String) {
            self.inputName = inputName
            self.newInputName = newInputName
        }
    }

    /// Gets the default settings for an input kind.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputDefaultSettings: OBSRequest {
        public typealias ResponseType = Response

        /// Input kind to get the default settings for
        public var inputKind: String

        public init(inputKind: String) {
            self.inputKind = inputKind
        }

        public struct Response: OBSRequestResponse {
            /// Object of default settings for the input kind
            public var defaultInputSettings: JSONValue
        }
    }

    /// Gets the settings of an input.
    /// - Note: Does not include defaults. To create the entire settings object, overlay `inputSettings` over the `defaultInputSettings` provided by `GetInputDefaultSettings`.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputSettings: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input to get the settings of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Object of settings for the input
            public var inputSettings: JSONValue

            /// The kind of the input
            public var inputKind: String
        }
    }

    /// Sets the settings of an input.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputSettings: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to set the settings of
        public var inputName: String

        /// Object of settings to apply
        public var inputSettings: JSONValue

        /// True == apply the settings on top of existing ones, False == reset the input to its defaults, then apply settings.
        /// - Important: Optional Behavior - `true`
        public var overlay: Bool?

        public init(inputName: String, inputSettings: JSONValue, overlay: Bool?) {
            self.inputName = inputName
            self.inputSettings = inputSettings
            self.overlay = overlay
        }

        enum CodingKeys: String, CodingKey {
            case inputName, inputSettings, overlay
        }
    }

    /// Gets the audio mute state of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputMute: OBSRequest {
        public typealias ResponseType = Response

        /// Name of input to get the mute state of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Whether the input is muted
            public var inputMuted: Bool
        }
    }

    /// Sets the audio mute state of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputMute: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to set the mute state of
        public var inputName: String

        /// Whether to mute the input or not
        public var inputMuted: Bool

        public init(inputName: String, inputMuted: Bool) {
            self.inputName = inputName
            self.inputMuted = inputMuted
        }
    }

    /// Toggles the audio mute state of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ToggleInputMute: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input to toggle the mute state of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Whether the input has been muted or unmuted
            public var inputMuted: Bool
        }
    }

    /// Gets the current volume setting of an input.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputVolume: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input to get the volume of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Volume setting in mul
            public var inputVolumeMul: Int

            /// Volume setting in dB
            public var inputVolumeDb: Int
        }
    }

    /// Sets the volume setting of an input.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputVolume: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to set the volume of
        public var inputName: String

        /// Volume setting in mul
        /// - Requires: Value Restrictions - `>= 0, <= 20`
        /// - Important: Optional Behavior - `inputVolumeDb` should be specified`
        public var inputVolumeMul: Int?

        /// Volume setting in dB
        /// - Requires: Value Restrictions - `>= -100, <= 26`
        /// - Important: Optional Behavior - `inputVolumeMul` should be specified`
        public var inputVolumeDb: Int?

        public init(inputName: String, inputVolumeMul: Int?, inputVolumeDb: Int?) {
            self.inputName = inputName
            self.inputVolumeMul = inputVolumeMul
            self.inputVolumeDb = inputVolumeDb
        }

        enum CodingKeys: String, CodingKey {
            case inputName, inputVolumeMul, inputVolumeDb
        }
    }

    /// Gets the audio balance of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputAudioBalance: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input to get the audio balance of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Audio balance value from 0.0-1.0
            public var inputAudioBalance: Int
        }
    }

    /// Sets the audio balance of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputAudioBalance: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to set the audio balance of
        public var inputName: String

        /// New audio balance value
        /// - Requires: Value Restrictions - `>= 0.0, <= 1.0`
        public var inputAudioBalance: Float

        public init(inputName: String, inputAudioBalance: Float) {
            self.inputName = inputName
            self.inputAudioBalance = inputAudioBalance
        }
    }

    /// Gets the audio sync offset of an input.
    /// - Note: The audio sync offset can be negative too!
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputAudioSyncOffset: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input to get the audio sync offset of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Audio sync offset in milliseconds
            public var inputAudioSyncOffset: Int
        }
    }

    /// Sets the audio sync offset of an input.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputAudioSyncOffset: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to set the audio sync offset of
        public var inputName: String

        /// New audio sync offset in milliseconds
        /// - Requires: Value Restrictions - `>= -950, <= 20000`
        public var inputAudioSyncOffset: Int

        public init(inputName: String, inputAudioSyncOffset: Int) {
            self.inputName = inputName
            self.inputAudioSyncOffset = inputAudioSyncOffset
        }
    }

    /// Gets the audio monitor type of an input.
    ///
    /// The available audio monitor types are:
    /// - `OBS_MONITORING_TYPE_NONE`
    /// - `OBS_MONITORING_TYPE_MONITOR_ONLY`
    /// - `OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT`
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputAudioMonitorType: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input to get the audio monitor type of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Audio monitor type
            public var monitorType: String
        }
    }

    /// Sets the audio monitor type of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputAudioMonitorType: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to set the audio monitor type of
        public var inputName: String

        /// Audio monitor type
        public var monitorType: String

        public init(inputName: String, monitorType: String) {
            self.inputName = inputName
            self.monitorType = monitorType
        }
    }

    /// Gets the enable state of all audio tracks of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputAudioTracks: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// Object of audio tracks and associated enable states
            public var inputAudioTracks: JSONValue
        }
    }

    /// Sets the enable state of audio tracks of an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetInputAudioTracks: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input
        public var inputName: String

        /// Track settings to apply
        public var inputAudioTracks: JSONValue

        public init(inputName: String, inputAudioTracks: JSONValue) {
            self.inputName = inputName
            self.inputAudioTracks = inputAudioTracks
        }
    }

    /// Gets the items of a list property from an input's properties.
    /// - Note: Use this in cases where an input provides a dynamic, selectable list of items. For example, display capture, where it provides a list of available displays.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetInputPropertiesListPropertyItems: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the input
        public var inputName: String

        /// Name of the list property to get the items of
        public var propertyName: String

        public init(inputName: String, propertyName: String) {
            self.inputName = inputName
            self.propertyName = propertyName
        }

        public struct Response: OBSRequestResponse {
            /// Array of items in the list property
            public var propertyItems: [JSONValue]
        }
    }

    /// Presses a button in the properties of an input.
    ///
    /// Some known `propertyName` values are:
    /// - `refreshnocache` - Browser source reload button
    /// - Note: Use this in cases where there is a button in the properties of an input that cannot be accessed in any other way. For example, browser sources, where there is a refresh button.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct PressInputPropertiesButton: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input
        public var inputName: String

        /// Name of the button property to press
        public var propertyName: String

        public init(inputName: String, propertyName: String) {
            self.inputName = inputName
            self.propertyName = propertyName
        }
    }

    /// Gets the status of a media input.
    ///
    /// Media States:
    /// - `OBS_MEDIA_STATE_NONE`
    /// - `OBS_MEDIA_STATE_PLAYING`
    /// - `OBS_MEDIA_STATE_OPENING`
    /// - `OBS_MEDIA_STATE_BUFFERING`
    /// - `OBS_MEDIA_STATE_PAUSED`
    /// - `OBS_MEDIA_STATE_STOPPED`
    /// - `OBS_MEDIA_STATE_ENDED`
    /// - `OBS_MEDIA_STATE_ERROR`
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetMediaInputStatus: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the media input
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }

        public struct Response: OBSRequestResponse {
            /// State of the media input
            public var mediaState: String

            /// Total duration of the playing media in milliseconds. `nil` if not playing
            public var mediaDuration: Int?

            /// Position of the cursor in milliseconds. `nil` if not playing
            public var mediaCursor: Int?
        }
    }

    /// Sets the cursor position of a media input.
    ///
    /// This request does not perform bounds checking of the cursor position.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetMediaInputCursor: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the media input
        public var inputName: String

        /// New cursor position to set
        /// - Requires: Value Restrictions - `>= 0`
        public var mediaCursor: Int

        public init(inputName: String, mediaCursor: Int) {
            self.inputName = inputName
            self.mediaCursor = mediaCursor
        }
    }

    /// Offsets the current cursor position of a media input by the specified value.
    ///
    /// This request does not perform bounds checking of the cursor position.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct OffsetMediaInputCursor: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the media input
        public var inputName: String

        /// Value to offset the current cursor position by
        public var mediaCursorOffset: Int

        public init(inputName: String, mediaCursorOffset: Int) {
            self.inputName = inputName
            self.mediaCursorOffset = mediaCursorOffset
        }
    }

    /// Triggers an action on a media input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct TriggerMediaInputAction: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the media input
        public var inputName: String

        /// Identifier of the `ObsMediaInputAction` enum
        public var mediaAction: OBSEnums.MediaInputAction

        public init(inputName: String, mediaAction: OBSEnums.MediaInputAction) {
            self.inputName = inputName
            self.mediaAction = mediaAction
        }
    }

    /// Gets the status of the virtualcam output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetVirtualCamStatus: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool
        }
    }

    /// Toggles the state of the virtualcam output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ToggleVirtualCam: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool
        }
    }

    /// Starts the virtualcam output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StartVirtualCam: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Stops the virtualcam output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StopVirtualCam: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Gets the status of the replay buffer output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetReplayBufferStatus: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool
        }
    }

    /// Toggles the state of the replay buffer output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ToggleReplayBuffer: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool
        }
    }

    /// Starts the replay buffer output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StartReplayBuffer: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Stops the replay buffer output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StopReplayBuffer: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Saves the contents of the replay buffer output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SaveReplayBuffer: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Gets the filename of the last replay buffer save file.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetLastReplayBufferReplay: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// File path
            public var savedReplayPath: String
        }
    }

    /// Gets the list of available outputs.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetOutputList: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Gets the status of an output.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetOutputStatus: OBSRequest {
        public typealias ResponseType = Response

        /// Output name
        public var outputName: String

        public init(outputName: String) {
            self.outputName = outputName
        }

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool

            /// Whether the output is reconnecting
            public var outputReconnecting: Bool

            /// Current formatted timecode string for the output
            public var outputTimecode: String

            /// Current duration in milliseconds for the output
            public var outputDuration: Int

            /// Congestion of the output
            public var outputCongestion: Int

            /// Number of bytes sent by the output
            public var outputBytes: Int

            /// Number of frames skipped by the output's process
            public var outputSkippedFrames: Int

            /// Total number of frames delivered by the output's process
            public var outputTotalFrames: Int
        }
    }

    /// Toggles the status of an output.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ToggleOutput: OBSRequest {
        public typealias ResponseType = Response

        /// Output name
        public var outputName: String

        public init(outputName: String) {
            self.outputName = outputName
        }

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool
        }
    }

    /// Starts an output.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StartOutput: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Output name
        public var outputName: String

        public init(outputName: String) {
            self.outputName = outputName
        }
    }

    /// Stops an output.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StopOutput: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Output name
        public var outputName: String

        public init(outputName: String) {
            self.outputName = outputName
        }
    }

    /// Gets the settings of an output.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetOutputSettings: OBSRequest {
        public typealias ResponseType = Response

        /// Output name
        public var outputName: String

        public init(outputName: String) {
            self.outputName = outputName
        }

        public struct Response: OBSRequestResponse {
            /// Output settings
            public var outputSettings: JSONValue
        }
    }

    /// Sets the settings of an output.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetOutputSettings: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Output name
        public var outputName: String

        /// Output settings
        public var outputSettings: JSONValue

        public init(outputName: String, outputSettings: JSONValue) {
            self.outputName = outputName
            self.outputSettings = outputSettings
        }
    }

    /// Gets the status of the record output.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetRecordStatus: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool

            /// Whether the output is paused
            public var ouputPaused: Bool

            /// Current formatted timecode string for the output
            public var outputTimecode: String

            /// Current duration in milliseconds for the output
            public var outputDuration: Int

            /// Number of bytes sent by the output
            public var outputBytes: Int
        }
    }

    /// Toggles the status of the record output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ToggleRecord: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Starts the record output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StartRecord: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Stops the record output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StopRecord: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// File name for the saved recording
            public var outputPath: String
        }
    }

    /// Toggles pause on the record output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ToggleRecordPause: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Pauses the record output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct PauseRecord: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Resumes the record output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ResumeRecord: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Gets a list of all scene items in a scene.
    ///
    /// Scenes only
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneItemList: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene to get the items of
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }

        public struct Response: OBSRequestResponse {
            /// Array of scene items in the scene
            public var sceneItems: [JSONValue]
        }
    }

    /// Basically GetSceneItemList, but for groups.
    ///
    /// Using groups at all in OBS is discouraged, as they are very broken under the hood. Please use nested scenes instead.
    ///
    /// Groups only
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetGroupSceneItemList: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the group to get the items of
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }

        public struct Response: OBSRequestResponse {
            /// Array of scene items in the group
            public var sceneItems: [JSONValue]
        }
    }

    /// Searches a scene for a source, and returns its id.
    ///
    /// Scenes and Groups
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneItemId: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene or group to search in
        public var sceneName: String

        /// Name of the source to find
        public var sourceName: String

        /// Number of matches to skip during search. >= 0 means first forward. -1 means last (top) item
        /// - Requires: Value Restrictions - `>= -1`
        /// - Important: Optional Behavior - `0`
        public var searchOffset: Int?

        public init(sceneName: String, sourceName: String, searchOffset: Int?) {
            self.sceneName = sceneName
            self.sourceName = sourceName
            self.searchOffset = searchOffset
        }

        public struct Response: OBSRequestResponse {
            /// Numeric ID of the scene item
            public var sceneItemId: Int
        }

        enum CodingKeys: String, CodingKey {
            case sceneName, sourceName, searchOffset
        }
    }

    /// Creates a new scene item using a source.
    ///
    /// Scenes only
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CreateSceneItem: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene to create the new item in
        public var sceneName: String

        /// Name of the source to add to the scene
        public var sourceName: String

        /// Enable state to apply to the scene item on creation
        /// - Important: Optional Behavior - `True`
        public var sceneItemEnabled: Bool?

        public init(sceneName: String, sourceName: String, sceneItemEnabled: Bool?) {
            self.sceneName = sceneName
            self.sourceName = sourceName
            self.sceneItemEnabled = sceneItemEnabled
        }

        public struct Response: OBSRequestResponse {
            /// Numeric ID of the scene item
            public var sceneItemId: Int
        }

        enum CodingKeys: String, CodingKey {
            case sceneName, sourceName, sceneItemEnabled
        }
    }

    /// Removes a scene item from a scene.
    ///
    /// Scenes only
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct RemoveSceneItem: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        public init(sceneName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
        }
    }

    /// Duplicates a scene item, copying all transform and crop info.
    ///
    /// Scenes only
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct DuplicateSceneItem: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        /// Name of the scene to create the duplicated item in
        /// - Important: Optional Behavior - `sceneName` is assumed`
        public var destinationSceneName: String?

        public init(sceneName: String, sceneItemId: Int, destinationSceneName: String?) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.destinationSceneName = destinationSceneName
        }

        public struct Response: OBSRequestResponse {
            /// Numeric ID of the duplicated scene item
            public var sceneItemId: Int
        }

        enum CodingKeys: String, CodingKey {
            case sceneName, sceneItemId, destinationSceneName
        }
    }

    /// Gets the transform and crop info of a scene item.
    ///
    /// Scenes and Groups
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneItemTransform: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        public init(sceneName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
        }

        public struct Response: OBSRequestResponse {
            /// Object containing scene item transform info
            public var sceneItemTransform: JSONValue
        }
    }

    /// Sets the transform and crop info of a scene item.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSceneItemTransform: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        /// Object containing scene item transform info to update
        public var sceneItemTransform: JSONValue

        public init(sceneName: String, sceneItemId: Int, sceneItemTransform: JSONValue) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemTransform = sceneItemTransform
        }
    }

    /// Gets the enable state of a scene item.
    ///
    /// Scenes and Groups
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneItemEnabled: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        public init(sceneName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
        }

        public struct Response: OBSRequestResponse {
            /// Whether the scene item is enabled. `true` for enabled, `false` for disabled
            public var sceneItemEnabled: Bool
        }
    }

    /// Sets the enable state of a scene item.
    ///
    /// Scenes and Groups
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSceneItemEnabled: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        /// New enable state of the scene item
        public var sceneItemEnabled: Bool

        public init(sceneName: String, sceneItemId: Int, sceneItemEnabled: Bool) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemEnabled = sceneItemEnabled
        }
    }

    /// Gets the lock state of a scene item.
    ///
    /// Scenes and Groups
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneItemLocked: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        public init(sceneName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
        }

        public struct Response: OBSRequestResponse {
            /// Whether the scene item is locked. `true` for locked, `false` for unlocked
            public var sceneItemLocked: Bool
        }
    }

    /// Sets the lock state of a scene item.
    ///
    /// Scenes and Group
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSceneItemLocked: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        /// New lock state of the scene item
        public var sceneItemLocked: Bool

        public init(sceneName: String, sceneItemId: Int, sceneItemLocked: Bool) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemLocked = sceneItemLocked
        }
    }

    /// Gets the index position of a scene item in a scene.
    ///
    /// An index of 0 is at the bottom of the source list in the UI.
    ///
    /// Scenes and Groups
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneItemIndex: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        public init(sceneName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
        }

        public struct Response: OBSRequestResponse {
            /// Index position of the scene item
            public var sceneItemIndex: Int
        }
    }

    /// Sets the index position of a scene item in a scene.
    ///
    /// Scenes and Groups
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSceneItemIndex: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        /// New index position of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemIndex: Int

        public init(sceneName: String, sceneItemId: Int, sceneItemIndex: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemIndex = sceneItemIndex
        }
    }

    /// Gets the blend mode of a scene item.
    ///
    /// Blend modes:
    /// - `OBS_BLEND_NORMAL`
    /// - `OBS_BLEND_ADDITIVE`
    /// - `OBS_BLEND_SUBTRACT`
    /// - `OBS_BLEND_SCREEN`
    /// - `OBS_BLEND_MULTIPLY`
    /// - `OBS_BLEND_LIGHTEN`
    /// - `OBS_BLEND_DARKEN`
    ///
    /// Scenes and Groups
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneItemBlendMode: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        public init(sceneName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
        }

        public struct Response: OBSRequestResponse {
            /// Current blend mode
            public var sceneItemBlendMode: String
        }
    }

    /// Sets the blend mode of a scene item.
    ///
    /// Scenes and Groups
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSceneItemBlendMode: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        /// - Requires: Value Restrictions - `>= 0`
        public var sceneItemId: Int

        /// New blend mode
        public var sceneItemBlendMode: String

        public init(sceneName: String, sceneItemId: Int, sceneItemBlendMode: String) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemBlendMode = sceneItemBlendMode
        }
    }

    /// Gets an array of all scenes in OBS.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Current program scene
            public var currentProgramSceneName: String

            /// Current preview scene. `nil` if not in studio mode
            public var currentPreviewSceneName: String?

            /// Array of scenes
            public var scenes: [JSONValue]
        }
    }

    /// Gets an array of all groups in OBS.
    ///
    /// Groups in OBS are actually scenes, but renamed and modified. In obs-websocket, we treat them as scenes where we can.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetGroupList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Array of group names
            public var groups: [String]
        }
    }

    /// Gets the current program scene.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetCurrentProgramScene: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Current program scene
            public var currentProgramSceneName: String
        }
    }

    /// Sets the current program scene.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetCurrentProgramScene: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Scene to set as the current program scene
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }
    }

    /// Gets the current preview scene.
    ///
    /// Only available when studio mode is enabled.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetCurrentPreviewScene: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Current preview scene
            public var currentPreviewSceneName: String
        }
    }

    /// Sets the current preview scene.
    ///
    /// Only available when studio mode is enabled.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetCurrentPreviewScene: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Scene to set as the current preview scene
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }
    }

    /// Creates a new scene in OBS.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CreateScene: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name for the new scene
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }
    }

    /// Removes a scene from OBS.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct RemoveScene: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene to remove
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }
    }

    /// Sets the name of a scene (rename).
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSceneName: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene to be renamed
        public var sceneName: String

        /// New name for the scene
        public var newSceneName: String

        public init(sceneName: String, newSceneName: String) {
            self.sceneName = sceneName
            self.newSceneName = newSceneName
        }
    }

    /// Gets the scene transition overridden for a scene.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneSceneTransitionOverride: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the scene
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }

        public struct Response: OBSRequestResponse {
            /// Name of the overridden scene transition, else `nil`
            public var transitionName: String?

            /// Duration of the overridden scene transition, else `nil`
            public var transitionDuration: Int?
        }
    }

    /// Gets the scene transition overridden for a scene.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetSceneSceneTransitionOverride: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the scene
        public var sceneName: String

        /// Name of the scene transition to use as override. Specify `null` to remove
        /// - Important: Excluded Behavior - `Unchanged`
        public var transitionName: Excludable<String>

        /// Duration to use for any overridden transition. Specify `null` to remove
        /// - Requires: Value Restrictions - `>= 50, <= 20000`
        /// - Important: Excluded Behavior - `Unchanged`
        public var transitionDuration: Excludable<Int>

        public init(sceneName: String, transitionName: Excludable<String>, transitionDuration: Excludable<Int>) {
            self.sceneName = sceneName
            self.transitionName = transitionName
            self.transitionDuration = transitionDuration
        }

        enum CodingKeys: String, CodingKey {
            case sceneName, transitionName, transitionDuration
        }
    }

    /// Gets the active and show state of a source.
    ///
    /// **Compatible with inputs and scenes.**
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSourceActive: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the source to get the active state of
        public var sourceName: String

        public init(sourceName: String) {
            self.sourceName = sourceName
        }

        public struct Response: OBSRequestResponse {
            /// Whether the source is showing in Program
            public var videoActive: Bool

            /// Whether the source is showing in the UI (Preview, Projector, Properties)
            public var videoShowing: Bool
        }
    }

    /// Gets a Base64-encoded screenshot of a source.
    ///
    /// The `imageWidth` and `imageHeight` parameters are treated as "scale to inner", meaning the smallest ratio will be used and the aspect ratio of the original resolution is kept.
    ///
    /// If `imageWidth` and `imageHeight` are not specified, the compressed image will use the full resolution of the source.
    ///
    /// **Compatible with inputs and scenes.**
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSourceScreenshot: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the source to take a screenshot of
        public var sourceName: String

        /// Image compression format to use. Use `GetVersion` to get compatible image formats
        public var imageFormat: String

        /// Width to scale the screenshot to
        /// - Requires: Value Restrictions - `>= 8, <= 4096`
        /// - Important: Optional Behavior - `Source value is used`
        public var imageWidth: Int?

        /// Height to scale the screenshot to
        /// - Requires: Value Restrictions - `>= 8, <= 4096`
        /// - Important: Optional Behavior - `Source value is used`
        public var imageHeight: Int?

        /// Compression quality to use. 0 for high compression, 100 for uncompressed. -1 to use "default" (whatever that means, idk)
        /// - Requires: Value Restrictions - `>= -1, <= 100`
        /// - Important: Optional Behavior - `-1`
        public var imageCompressionQuality: Int?

        public init(sourceName: String, imageFormat: String, imageWidth: Int?, imageHeight: Int?, imageCompressionQuality: Int?) {
            self.sourceName = sourceName
            self.imageFormat = imageFormat
            self.imageWidth = imageWidth
            self.imageHeight = imageHeight
            self.imageCompressionQuality = imageCompressionQuality
        }

        public struct Response: OBSRequestResponse {
            /// Base64-encoded screenshot
            public var imageData: String
        }

        enum CodingKeys: String, CodingKey {
            case sourceName, imageFormat, imageWidth, imageHeight, imageCompressionQuality
        }
    }

    /// Saves a screenshot of a source to the filesystem.
    ///
    /// The `imageWidth` and `imageHeight` parameters are treated as "scale to inner", meaning the smallest ratio will be used and the aspect ratio of the original resolution is kept.
    ///
    /// If `imageWidth` and `imageHeight` are not specified, the compressed image will use the full resolution of the source.
    ///
    /// **Compatible with inputs and scenes.**
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SaveSourceScreenshot: OBSRequest {
        public typealias ResponseType = Response

        /// Name of the source to take a screenshot of
        public var sourceName: String

        /// Image compression format to use. Use `GetVersion` to get compatible image formats
        public var imageFormat: String

        /// Path to save the screenshot file to. Eg. `C:\Users\user\Desktop\screenshot.png`
        public var imageFilePath: String

        /// Width to scale the screenshot to
        /// - Requires: Value Restrictions - `>= 8, <= 4096`
        /// - Important: Optional Behavior - `Source value is used`
        public var imageWidth: Int?

        /// Height to scale the screenshot to
        /// - Requires: Value Restrictions - `>= 8, <= 4096`
        /// - Important: Optional Behavior - `Source value is used`
        public var imageHeight: Int?

        /// Compression quality to use. 0 for high compression, 100 for uncompressed. -1 to use "default" (whatever that means, idk)
        /// - Requires: Value Restrictions - `>= -1, <= 100`
        /// - Important: Optional Behavior - `-1`
        public var imageCompressionQuality: Int?

        public init(sourceName: String, imageFormat: String, imageFilePath: String, imageWidth: Int?, imageHeight: Int?, imageCompressionQuality: Int?) {
            self.sourceName = sourceName
            self.imageFormat = imageFormat
            self.imageFilePath = imageFilePath
            self.imageWidth = imageWidth
            self.imageHeight = imageHeight
            self.imageCompressionQuality = imageCompressionQuality
        }

        public struct Response: OBSRequestResponse {
            /// Base64-encoded screenshot
            public var imageData: String
        }

        enum CodingKeys: String, CodingKey {
            case sourceName, imageFormat, imageFilePath, imageWidth, imageHeight, imageCompressionQuality
        }
    }

    /// Gets the status of the stream output.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetStreamStatus: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Whether the output is active
            public var outputActive: Bool

            /// Whether the output is currently reconnecting
            public var outputReconnecting: Bool

            /// Current formatted timecode string for the output
            public var outputTimecode: String

            /// Current duration in milliseconds for the output
            public var outputDuration: Int

            /// Congestion of the output
            public var outputCongestion: Int

            /// Number of bytes sent by the output
            public var outputBytes: Int

            /// Number of frames skipped by the output's process
            public var outputSkippedFrames: Int

            /// Total number of frames delivered by the output's process
            public var outputTotalFrames: Int
        }
    }

    /// Toggles the status of the stream output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ToggleStream: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// New state of the stream output
            public var outputActive: Bool
        }
    }

    /// Starts the stream output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StartStream: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Stops the stream output.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StopStream: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Sends CEA-608 caption text over the stream output.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SendStreamCaption: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Caption text
        public var captionText: String

        public init(captionText: String) {
            self.captionText = captionText
        }
    }

    /// Gets an array of all available transition kinds.
    ///
    /// Similar to `GetInputKindList`
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetTransitionKindList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Array of transition kinds
            public var transitionKinds: [String]
        }
    }

    /// Gets an array of all scene transitions in OBS.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetSceneTransitionList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Name of the current scene transition. Can be `nil`
            public var currentSceneTransitionName: String?

            /// Kind of the current scene transition. Can be `nil`
            public var currentSceneTransitionKind: String?

            /// Array of transitions
            public var transitions: [JSONValue]
        }
    }

    /// Gets information about the current scene transition.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetCurrentSceneTransition: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Name of the transition
            public var transitionName: String

            /// Kind of the transition
            public var transitionKind: String

            /// Whether the transition uses a fixed (unconfigurable) duration
            public var transitionFixed: Bool

            /// Configured transition duration in milliseconds. `nil` if transition is fixed
            public var transitionDuration: Int?

            /// Whether the transition supports being configured
            public var transitionConfigurable: Bool

            /// Object of settings for the transition. `nil` if transition is not configurable
            public var transitionSettings: JSONValue?
        }
    }

    /// Sets the current scene transition.
    ///
    /// Small note: While the namespace of scene transitions is generally unique, that uniqueness is not a guarantee as it is with other resources like inputs.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetCurrentSceneTransition: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the transition to make active
        public var transitionName: String

        public init(transitionName: String) {
            self.transitionName = transitionName
        }
    }

    /// Sets the duration of the current scene transition, if it is not fixed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetCurrentSceneTransitionDuration: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Duration in milliseconds
        /// - Requires: Value Restrictions - `>= 50, <= 20000`
        public var transitionDuration: Int

        public init(transitionDuration: Int) {
            self.transitionDuration = transitionDuration
        }
    }

    /// Sets the settings of the current scene transition.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetCurrentSceneTransitionSettings: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Settings object to apply to the transition. Can be `{}`
        public var transitionSettings: JSONValue

        /// Whether to overlay over the current settings or replace them
        /// - Important: Optional Behavior - `true`
        public var overlay: Bool?

        public init(transitionSettings: JSONValue, overlay: Bool?) {
            self.transitionSettings = transitionSettings
            self.overlay = overlay
        }

        enum CodingKeys: String, CodingKey {
            case transitionSettings, overlay
        }
    }

    /// Gets the cursor position of the current scene transition.
    /// - Note: `transitionCursor` will return 1.0 when the transition is inactive.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetCurrentSceneTransitionCursor: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Cursor position, between 0.0 and 1.0
            public var transitionCursor: Int
        }
    }

    /// Triggers the current scene transition. Same functionality as the `Transition` button in studio mode.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct TriggerStudioModeTransition: OBSRequest {
        public typealias ResponseType = EmptyResponse

        public init() {}
    }

    /// Sets the position of the TBar.
    ///
    /// **Very important note**: This will be deprecated and replaced in a future version of obs-websocket.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetTBarPosition: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// New position
        /// - Requires: Value Restrictions - `>= 0.0, <= 1.0`
        public var position: Float

        /// Whether to release the TBar. Only set `false` if you know that you will be sending another position update
        /// - Important: Optional Behavior - `true`
        public var release: Bool?

        public init(position: Float, release: Bool?) {
            self.position = position
            self.release = release
        }

        enum CodingKeys: String, CodingKey {
            case position, release
        }
    }

    /// Gets whether studio is enabled.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetStudioModeEnabled: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// Whether studio mode is enabled
            public var studioModeEnabled: Bool
        }
    }

    /// Enables or disables studio mode
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SetStudioModeEnabled: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// True == Enabled, False == Disabled
        public var studioModeEnabled: Bool

        public init(studioModeEnabled: Bool) {
            self.studioModeEnabled = studioModeEnabled
        }
    }

    /// Opens the properties dialog of an input.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct OpenInputPropertiesDialog: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to open the dialog of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }
    }

    /// Opens the filters dialog of an input.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct OpenInputFiltersDialog: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to open the dialog of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }
    }

    /// Opens the interact dialog of an input.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct OpenInputInteractDialog: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the input to open the dialog of
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }
    }

    /// Gets a list of connected monitors and information about them.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct GetMonitorList: OBSRequest {
        public typealias ResponseType = Response

        public init() {}

        public struct Response: OBSRequestResponse {
            /// a list of detected monitors with some information
            public var monitors: [JSONValue]
        }
    }

    /// Opens a projector for a specific output video mix.
    ///
    /// Mix types:
    /// - `OBS_WEBSOCKET_VIDEO_MIX_TYPE_PREVIEW`
    /// - `OBS_WEBSOCKET_VIDEO_MIX_TYPE_PROGRAM`
    /// - `OBS_WEBSOCKET_VIDEO_MIX_TYPE_MULTIVIEW`
    /// - Note: This request serves to provide feature parity with 4.x. It is very likely to be changed/deprecated in a future release.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct OpenVideoMixProjector: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Type of mix to open
        public var videoMixType: String

        /// Monitor index, use `GetMonitorList` to obtain index
        /// - Important: Optional Behavior - `-1: Opens projector in windowed mode`
        public var monitorIndex: Int?

        /// Size/Position data for a windowed projector, in Qt Base64 encoded format. Mutually exclusive with `monitorIndex`
        /// - Important: Optional Behavior - `N/A`
        public var projectorGeometry: String?

        public init(videoMixType: String, monitorIndex: Int?, projectorGeometry: String?) {
            self.videoMixType = videoMixType
            self.monitorIndex = monitorIndex
            self.projectorGeometry = projectorGeometry
        }

        enum CodingKeys: String, CodingKey {
            case videoMixType, monitorIndex, projectorGeometry
        }
    }

    /// Opens a projector for a source.
    /// - Note: This request serves to provide feature parity with 4.x. It is very likely to be changed/deprecated in a future release.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct OpenSourceProjector: OBSRequest {
        public typealias ResponseType = EmptyResponse

        /// Name of the source to open a projector for
        public var sourceName: String

        /// Monitor index, use `GetMonitorList` to obtain index
        /// - Important: Optional Behavior - `-1: Opens projector in windowed mode`
        public var monitorIndex: Int?

        /// Size/Position data for a windowed projector, in Qt Base64 encoded format. Mutually exclusive with `monitorIndex`
        /// - Important: Optional Behavior - `N/A`
        public var projectorGeometry: String?

        public init(sourceName: String, monitorIndex: Int?, projectorGeometry: String?) {
            self.sourceName = sourceName
            self.monitorIndex = monitorIndex
            self.projectorGeometry = projectorGeometry
        }

        enum CodingKeys: String, CodingKey {
            case sourceName, monitorIndex, projectorGeometry
        }
    }

    public enum AllTypes: String, Codable {
        case GetPersistentData
        case SetPersistentData
        case GetSceneCollectionList
        case SetCurrentSceneCollection
        case CreateSceneCollection
        case GetProfileList
        case SetCurrentProfile
        case CreateProfile
        case RemoveProfile
        case GetProfileParameter
        case SetProfileParameter
        case GetVideoSettings
        case SetVideoSettings
        case GetStreamServiceSettings
        case SetStreamServiceSettings
        case GetRecordDirectory
        case GetSourceFilterList
        case GetSourceFilterDefaultSettings
        case CreateSourceFilter
        case RemoveSourceFilter
        case SetSourceFilterName
        case GetSourceFilter
        case SetSourceFilterIndex
        case SetSourceFilterSettings
        case SetSourceFilterEnabled
        case GetVersion
        case GetStats
        case BroadcastCustomEvent
        case CallVendorRequest
        case GetHotkeyList
        case TriggerHotkeyByName
        case TriggerHotkeyByKeySequence
        case Sleep
        case GetInputList
        case GetInputKindList
        case GetSpecialInputs
        case CreateInput
        case RemoveInput
        case SetInputName
        case GetInputDefaultSettings
        case GetInputSettings
        case SetInputSettings
        case GetInputMute
        case SetInputMute
        case ToggleInputMute
        case GetInputVolume
        case SetInputVolume
        case GetInputAudioBalance
        case SetInputAudioBalance
        case GetInputAudioSyncOffset
        case SetInputAudioSyncOffset
        case GetInputAudioMonitorType
        case SetInputAudioMonitorType
        case GetInputAudioTracks
        case SetInputAudioTracks
        case GetInputPropertiesListPropertyItems
        case PressInputPropertiesButton
        case GetMediaInputStatus
        case SetMediaInputCursor
        case OffsetMediaInputCursor
        case TriggerMediaInputAction
        case GetVirtualCamStatus
        case ToggleVirtualCam
        case StartVirtualCam
        case StopVirtualCam
        case GetReplayBufferStatus
        case ToggleReplayBuffer
        case StartReplayBuffer
        case StopReplayBuffer
        case SaveReplayBuffer
        case GetLastReplayBufferReplay
        case GetOutputList
        case GetOutputStatus
        case ToggleOutput
        case StartOutput
        case StopOutput
        case GetOutputSettings
        case SetOutputSettings
        case GetRecordStatus
        case ToggleRecord
        case StartRecord
        case StopRecord
        case ToggleRecordPause
        case PauseRecord
        case ResumeRecord
        case GetSceneItemList
        case GetGroupSceneItemList
        case GetSceneItemId
        case CreateSceneItem
        case RemoveSceneItem
        case DuplicateSceneItem
        case GetSceneItemTransform
        case SetSceneItemTransform
        case GetSceneItemEnabled
        case SetSceneItemEnabled
        case GetSceneItemLocked
        case SetSceneItemLocked
        case GetSceneItemIndex
        case SetSceneItemIndex
        case GetSceneItemBlendMode
        case SetSceneItemBlendMode
        case GetSceneList
        case GetGroupList
        case GetCurrentProgramScene
        case SetCurrentProgramScene
        case GetCurrentPreviewScene
        case SetCurrentPreviewScene
        case CreateScene
        case RemoveScene
        case SetSceneName
        case GetSceneSceneTransitionOverride
        case SetSceneSceneTransitionOverride
        case GetSourceActive
        case GetSourceScreenshot
        case SaveSourceScreenshot
        case GetStreamStatus
        case ToggleStream
        case StartStream
        case StopStream
        case SendStreamCaption
        case GetTransitionKindList
        case GetSceneTransitionList
        case GetCurrentSceneTransition
        case SetCurrentSceneTransition
        case SetCurrentSceneTransitionDuration
        case SetCurrentSceneTransitionSettings
        case GetCurrentSceneTransitionCursor
        case TriggerStudioModeTransition
        case SetTBarPosition
        case GetStudioModeEnabled
        case SetStudioModeEnabled
        case OpenInputPropertiesDialog
        case OpenInputFiltersDialog
        case OpenInputInteractDialog
        case GetMonitorList
        case OpenVideoMixProjector
        case OpenSourceProjector
        
        public func convertResponseData(_ resData: JSONValue?) throws -> OBSRequestResponse? {
            guard let data = resData else { return nil }
            
            switch self {
            case .GetPersistentData:
                return try data.toCodable(OBSRequests.GetPersistentData.ResponseType.self)
            case .SetPersistentData:
                return try data.toCodable(OBSRequests.SetPersistentData.ResponseType.self)
            case .GetSceneCollectionList:
                return try data.toCodable(OBSRequests.GetSceneCollectionList.ResponseType.self)
            case .SetCurrentSceneCollection:
                return try data.toCodable(OBSRequests.SetCurrentSceneCollection.ResponseType.self)
            case .CreateSceneCollection:
                return try data.toCodable(OBSRequests.CreateSceneCollection.ResponseType.self)
            case .GetProfileList:
                return try data.toCodable(OBSRequests.GetProfileList.ResponseType.self)
            case .SetCurrentProfile:
                return try data.toCodable(OBSRequests.SetCurrentProfile.ResponseType.self)
            case .CreateProfile:
                return try data.toCodable(OBSRequests.CreateProfile.ResponseType.self)
            case .RemoveProfile:
                return try data.toCodable(OBSRequests.RemoveProfile.ResponseType.self)
            case .GetProfileParameter:
                return try data.toCodable(OBSRequests.GetProfileParameter.ResponseType.self)
            case .SetProfileParameter:
                return try data.toCodable(OBSRequests.SetProfileParameter.ResponseType.self)
            case .GetVideoSettings:
                return try data.toCodable(OBSRequests.GetVideoSettings.ResponseType.self)
            case .SetVideoSettings:
                return try data.toCodable(OBSRequests.SetVideoSettings.ResponseType.self)
            case .GetStreamServiceSettings:
                return try data.toCodable(OBSRequests.GetStreamServiceSettings.ResponseType.self)
            case .SetStreamServiceSettings:
                return try data.toCodable(OBSRequests.SetStreamServiceSettings.ResponseType.self)
            case .GetRecordDirectory:
                return try data.toCodable(OBSRequests.GetRecordDirectory.ResponseType.self)
            case .GetSourceFilterList:
                return try data.toCodable(OBSRequests.GetSourceFilterList.ResponseType.self)
            case .GetSourceFilterDefaultSettings:
                return try data.toCodable(OBSRequests.GetSourceFilterDefaultSettings.ResponseType.self)
            case .CreateSourceFilter:
                return try data.toCodable(OBSRequests.CreateSourceFilter.ResponseType.self)
            case .RemoveSourceFilter:
                return try data.toCodable(OBSRequests.RemoveSourceFilter.ResponseType.self)
            case .SetSourceFilterName:
                return try data.toCodable(OBSRequests.SetSourceFilterName.ResponseType.self)
            case .GetSourceFilter:
                return try data.toCodable(OBSRequests.GetSourceFilter.ResponseType.self)
            case .SetSourceFilterIndex:
                return try data.toCodable(OBSRequests.SetSourceFilterIndex.ResponseType.self)
            case .SetSourceFilterSettings:
                return try data.toCodable(OBSRequests.SetSourceFilterSettings.ResponseType.self)
            case .SetSourceFilterEnabled:
                return try data.toCodable(OBSRequests.SetSourceFilterEnabled.ResponseType.self)
            case .GetVersion:
                return try data.toCodable(OBSRequests.GetVersion.ResponseType.self)
            case .GetStats:
                return try data.toCodable(OBSRequests.GetStats.ResponseType.self)
                case .BroadcastCustomEvent:
        return try data.toCodable(OBSRequests.EmptyResponse.self)
        // return OBSRequests.BroadcastCustomEvent<E: OBSEvent>.ResponseType.self
            case .CallVendorRequest:
                return try data.toCodable(OBSRequests.CallVendorRequest.ResponseType.self)
            case .GetHotkeyList:
                return try data.toCodable(OBSRequests.GetHotkeyList.ResponseType.self)
            case .TriggerHotkeyByName:
                return try data.toCodable(OBSRequests.TriggerHotkeyByName.ResponseType.self)
            case .TriggerHotkeyByKeySequence:
                return try data.toCodable(OBSRequests.TriggerHotkeyByKeySequence.ResponseType.self)
            case .Sleep:
                return try data.toCodable(OBSRequests.Sleep.ResponseType.self)
            case .GetInputList:
                return try data.toCodable(OBSRequests.GetInputList.ResponseType.self)
            case .GetInputKindList:
                return try data.toCodable(OBSRequests.GetInputKindList.ResponseType.self)
            case .GetSpecialInputs:
                return try data.toCodable(OBSRequests.GetSpecialInputs.ResponseType.self)
            case .CreateInput:
                return try data.toCodable(OBSRequests.CreateInput.ResponseType.self)
            case .RemoveInput:
                return try data.toCodable(OBSRequests.RemoveInput.ResponseType.self)
            case .SetInputName:
                return try data.toCodable(OBSRequests.SetInputName.ResponseType.self)
            case .GetInputDefaultSettings:
                return try data.toCodable(OBSRequests.GetInputDefaultSettings.ResponseType.self)
            case .GetInputSettings:
                return try data.toCodable(OBSRequests.GetInputSettings.ResponseType.self)
            case .SetInputSettings:
                return try data.toCodable(OBSRequests.SetInputSettings.ResponseType.self)
            case .GetInputMute:
                return try data.toCodable(OBSRequests.GetInputMute.ResponseType.self)
            case .SetInputMute:
                return try data.toCodable(OBSRequests.SetInputMute.ResponseType.self)
            case .ToggleInputMute:
                return try data.toCodable(OBSRequests.ToggleInputMute.ResponseType.self)
            case .GetInputVolume:
                return try data.toCodable(OBSRequests.GetInputVolume.ResponseType.self)
            case .SetInputVolume:
                return try data.toCodable(OBSRequests.SetInputVolume.ResponseType.self)
            case .GetInputAudioBalance:
                return try data.toCodable(OBSRequests.GetInputAudioBalance.ResponseType.self)
            case .SetInputAudioBalance:
                return try data.toCodable(OBSRequests.SetInputAudioBalance.ResponseType.self)
            case .GetInputAudioSyncOffset:
                return try data.toCodable(OBSRequests.GetInputAudioSyncOffset.ResponseType.self)
            case .SetInputAudioSyncOffset:
                return try data.toCodable(OBSRequests.SetInputAudioSyncOffset.ResponseType.self)
            case .GetInputAudioMonitorType:
                return try data.toCodable(OBSRequests.GetInputAudioMonitorType.ResponseType.self)
            case .SetInputAudioMonitorType:
                return try data.toCodable(OBSRequests.SetInputAudioMonitorType.ResponseType.self)
            case .GetInputAudioTracks:
                return try data.toCodable(OBSRequests.GetInputAudioTracks.ResponseType.self)
            case .SetInputAudioTracks:
                return try data.toCodable(OBSRequests.SetInputAudioTracks.ResponseType.self)
            case .GetInputPropertiesListPropertyItems:
                return try data.toCodable(OBSRequests.GetInputPropertiesListPropertyItems.ResponseType.self)
            case .PressInputPropertiesButton:
                return try data.toCodable(OBSRequests.PressInputPropertiesButton.ResponseType.self)
            case .GetMediaInputStatus:
                return try data.toCodable(OBSRequests.GetMediaInputStatus.ResponseType.self)
            case .SetMediaInputCursor:
                return try data.toCodable(OBSRequests.SetMediaInputCursor.ResponseType.self)
            case .OffsetMediaInputCursor:
                return try data.toCodable(OBSRequests.OffsetMediaInputCursor.ResponseType.self)
            case .TriggerMediaInputAction:
                return try data.toCodable(OBSRequests.TriggerMediaInputAction.ResponseType.self)
            case .GetVirtualCamStatus:
                return try data.toCodable(OBSRequests.GetVirtualCamStatus.ResponseType.self)
            case .ToggleVirtualCam:
                return try data.toCodable(OBSRequests.ToggleVirtualCam.ResponseType.self)
            case .StartVirtualCam:
                return try data.toCodable(OBSRequests.StartVirtualCam.ResponseType.self)
            case .StopVirtualCam:
                return try data.toCodable(OBSRequests.StopVirtualCam.ResponseType.self)
            case .GetReplayBufferStatus:
                return try data.toCodable(OBSRequests.GetReplayBufferStatus.ResponseType.self)
            case .ToggleReplayBuffer:
                return try data.toCodable(OBSRequests.ToggleReplayBuffer.ResponseType.self)
            case .StartReplayBuffer:
                return try data.toCodable(OBSRequests.StartReplayBuffer.ResponseType.self)
            case .StopReplayBuffer:
                return try data.toCodable(OBSRequests.StopReplayBuffer.ResponseType.self)
            case .SaveReplayBuffer:
                return try data.toCodable(OBSRequests.SaveReplayBuffer.ResponseType.self)
            case .GetLastReplayBufferReplay:
                return try data.toCodable(OBSRequests.GetLastReplayBufferReplay.ResponseType.self)
            case .GetOutputList:
                return try data.toCodable(OBSRequests.GetOutputList.ResponseType.self)
            case .GetOutputStatus:
                return try data.toCodable(OBSRequests.GetOutputStatus.ResponseType.self)
            case .ToggleOutput:
                return try data.toCodable(OBSRequests.ToggleOutput.ResponseType.self)
            case .StartOutput:
                return try data.toCodable(OBSRequests.StartOutput.ResponseType.self)
            case .StopOutput:
                return try data.toCodable(OBSRequests.StopOutput.ResponseType.self)
            case .GetOutputSettings:
                return try data.toCodable(OBSRequests.GetOutputSettings.ResponseType.self)
            case .SetOutputSettings:
                return try data.toCodable(OBSRequests.SetOutputSettings.ResponseType.self)
            case .GetRecordStatus:
                return try data.toCodable(OBSRequests.GetRecordStatus.ResponseType.self)
            case .ToggleRecord:
                return try data.toCodable(OBSRequests.ToggleRecord.ResponseType.self)
            case .StartRecord:
                return try data.toCodable(OBSRequests.StartRecord.ResponseType.self)
            case .StopRecord:
                return try data.toCodable(OBSRequests.StopRecord.ResponseType.self)
            case .ToggleRecordPause:
                return try data.toCodable(OBSRequests.ToggleRecordPause.ResponseType.self)
            case .PauseRecord:
                return try data.toCodable(OBSRequests.PauseRecord.ResponseType.self)
            case .ResumeRecord:
                return try data.toCodable(OBSRequests.ResumeRecord.ResponseType.self)
            case .GetSceneItemList:
                return try data.toCodable(OBSRequests.GetSceneItemList.ResponseType.self)
            case .GetGroupSceneItemList:
                return try data.toCodable(OBSRequests.GetGroupSceneItemList.ResponseType.self)
            case .GetSceneItemId:
                return try data.toCodable(OBSRequests.GetSceneItemId.ResponseType.self)
            case .CreateSceneItem:
                return try data.toCodable(OBSRequests.CreateSceneItem.ResponseType.self)
            case .RemoveSceneItem:
                return try data.toCodable(OBSRequests.RemoveSceneItem.ResponseType.self)
            case .DuplicateSceneItem:
                return try data.toCodable(OBSRequests.DuplicateSceneItem.ResponseType.self)
            case .GetSceneItemTransform:
                return try data.toCodable(OBSRequests.GetSceneItemTransform.ResponseType.self)
            case .SetSceneItemTransform:
                return try data.toCodable(OBSRequests.SetSceneItemTransform.ResponseType.self)
            case .GetSceneItemEnabled:
                return try data.toCodable(OBSRequests.GetSceneItemEnabled.ResponseType.self)
            case .SetSceneItemEnabled:
                return try data.toCodable(OBSRequests.SetSceneItemEnabled.ResponseType.self)
            case .GetSceneItemLocked:
                return try data.toCodable(OBSRequests.GetSceneItemLocked.ResponseType.self)
            case .SetSceneItemLocked:
                return try data.toCodable(OBSRequests.SetSceneItemLocked.ResponseType.self)
            case .GetSceneItemIndex:
                return try data.toCodable(OBSRequests.GetSceneItemIndex.ResponseType.self)
            case .SetSceneItemIndex:
                return try data.toCodable(OBSRequests.SetSceneItemIndex.ResponseType.self)
            case .GetSceneItemBlendMode:
                return try data.toCodable(OBSRequests.GetSceneItemBlendMode.ResponseType.self)
            case .SetSceneItemBlendMode:
                return try data.toCodable(OBSRequests.SetSceneItemBlendMode.ResponseType.self)
            case .GetSceneList:
                return try data.toCodable(OBSRequests.GetSceneList.ResponseType.self)
            case .GetGroupList:
                return try data.toCodable(OBSRequests.GetGroupList.ResponseType.self)
            case .GetCurrentProgramScene:
                return try data.toCodable(OBSRequests.GetCurrentProgramScene.ResponseType.self)
            case .SetCurrentProgramScene:
                return try data.toCodable(OBSRequests.SetCurrentProgramScene.ResponseType.self)
            case .GetCurrentPreviewScene:
                return try data.toCodable(OBSRequests.GetCurrentPreviewScene.ResponseType.self)
            case .SetCurrentPreviewScene:
                return try data.toCodable(OBSRequests.SetCurrentPreviewScene.ResponseType.self)
            case .CreateScene:
                return try data.toCodable(OBSRequests.CreateScene.ResponseType.self)
            case .RemoveScene:
                return try data.toCodable(OBSRequests.RemoveScene.ResponseType.self)
            case .SetSceneName:
                return try data.toCodable(OBSRequests.SetSceneName.ResponseType.self)
            case .GetSceneSceneTransitionOverride:
                return try data.toCodable(OBSRequests.GetSceneSceneTransitionOverride.ResponseType.self)
            case .SetSceneSceneTransitionOverride:
                return try data.toCodable(OBSRequests.SetSceneSceneTransitionOverride.ResponseType.self)
            case .GetSourceActive:
                return try data.toCodable(OBSRequests.GetSourceActive.ResponseType.self)
            case .GetSourceScreenshot:
                return try data.toCodable(OBSRequests.GetSourceScreenshot.ResponseType.self)
            case .SaveSourceScreenshot:
                return try data.toCodable(OBSRequests.SaveSourceScreenshot.ResponseType.self)
            case .GetStreamStatus:
                return try data.toCodable(OBSRequests.GetStreamStatus.ResponseType.self)
            case .ToggleStream:
                return try data.toCodable(OBSRequests.ToggleStream.ResponseType.self)
            case .StartStream:
                return try data.toCodable(OBSRequests.StartStream.ResponseType.self)
            case .StopStream:
                return try data.toCodable(OBSRequests.StopStream.ResponseType.self)
            case .SendStreamCaption:
                return try data.toCodable(OBSRequests.SendStreamCaption.ResponseType.self)
            case .GetTransitionKindList:
                return try data.toCodable(OBSRequests.GetTransitionKindList.ResponseType.self)
            case .GetSceneTransitionList:
                return try data.toCodable(OBSRequests.GetSceneTransitionList.ResponseType.self)
            case .GetCurrentSceneTransition:
                return try data.toCodable(OBSRequests.GetCurrentSceneTransition.ResponseType.self)
            case .SetCurrentSceneTransition:
                return try data.toCodable(OBSRequests.SetCurrentSceneTransition.ResponseType.self)
            case .SetCurrentSceneTransitionDuration:
                return try data.toCodable(OBSRequests.SetCurrentSceneTransitionDuration.ResponseType.self)
            case .SetCurrentSceneTransitionSettings:
                return try data.toCodable(OBSRequests.SetCurrentSceneTransitionSettings.ResponseType.self)
            case .GetCurrentSceneTransitionCursor:
                return try data.toCodable(OBSRequests.GetCurrentSceneTransitionCursor.ResponseType.self)
            case .TriggerStudioModeTransition:
                return try data.toCodable(OBSRequests.TriggerStudioModeTransition.ResponseType.self)
            case .SetTBarPosition:
                return try data.toCodable(OBSRequests.SetTBarPosition.ResponseType.self)
            case .GetStudioModeEnabled:
                return try data.toCodable(OBSRequests.GetStudioModeEnabled.ResponseType.self)
            case .SetStudioModeEnabled:
                return try data.toCodable(OBSRequests.SetStudioModeEnabled.ResponseType.self)
            case .OpenInputPropertiesDialog:
                return try data.toCodable(OBSRequests.OpenInputPropertiesDialog.ResponseType.self)
            case .OpenInputFiltersDialog:
                return try data.toCodable(OBSRequests.OpenInputFiltersDialog.ResponseType.self)
            case .OpenInputInteractDialog:
                return try data.toCodable(OBSRequests.OpenInputInteractDialog.ResponseType.self)
            case .GetMonitorList:
                return try data.toCodable(OBSRequests.GetMonitorList.ResponseType.self)
            case .OpenVideoMixProjector:
                return try data.toCodable(OBSRequests.OpenVideoMixProjector.ResponseType.self)
            case .OpenSourceProjector:
                return try data.toCodable(OBSRequests.OpenSourceProjector.ResponseType.self)
            }
        }
    }
}

extension OBSRequests.CreateSourceFilter: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sourceName, forKey: .sourceName)
        try container.encode(filterName, forKey: .filterName)
        try container.encode(filterKind, forKey: .filterKind)
        try container.encodeIfPresent(filterSettings, forKey: .filterSettings)
    }
}

extension OBSRequests.CreateSourceFilter: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sourceName = try container.decode(String.self, forKey: .sourceName)
        self.filterName = try container.decode(String.self, forKey: .filterName)
        self.filterKind = try container.decode(String.self, forKey: .filterKind)
        self.filterSettings = try container.decodeIfPresent(JSONValue.self, forKey: .filterSettings)
    }
}

extension OBSRequests.SetSceneSceneTransitionOverride: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sceneName, forKey: .sceneName)
        try container.encodeIfPresent(transitionName, forKey: .transitionName)
        try container.encodeIfPresent(transitionDuration, forKey: .transitionDuration)
    }
}

extension OBSRequests.SetSceneSceneTransitionOverride: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sceneName = try container.decode(String.self, forKey: .sceneName)
        self.transitionName = try container.decodeIfPresent(Excludable<String>.self, forKey: .transitionName) ?? .excluded
        self.transitionDuration = try container.decodeIfPresent(Excludable<Int>.self, forKey: .transitionDuration) ?? .excluded
    }
}

extension OBSRequests.SetCurrentSceneTransitionSettings: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(transitionSettings, forKey: .transitionSettings)
        try container.encodeIfPresent(overlay, forKey: .overlay)
    }
}

extension OBSRequests.SetCurrentSceneTransitionSettings: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.transitionSettings = try container.decode(JSONValue.self, forKey: .transitionSettings)
        self.overlay = try container.decodeIfPresent(Bool.self, forKey: .overlay)
    }
}

extension OBSRequests.GetInputKindList: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(unversioned, forKey: .unversioned)
    }
}

extension OBSRequests.GetInputKindList: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.unversioned = try container.decodeIfPresent(Bool.self, forKey: .unversioned)
    }
}

extension OBSRequests.GetInputList: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(inputKind, forKey: .inputKind)
    }
}

extension OBSRequests.GetInputList: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.inputKind = try container.decodeIfPresent(String.self, forKey: .inputKind)
    }
}

extension OBSRequests.SetSourceFilterSettings: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sourceName, forKey: .sourceName)
        try container.encode(filterName, forKey: .filterName)
        try container.encode(filterSettings, forKey: .filterSettings)
        try container.encodeIfPresent(overlay, forKey: .overlay)
    }
}

extension OBSRequests.SetSourceFilterSettings: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sourceName = try container.decode(String.self, forKey: .sourceName)
        self.filterName = try container.decode(String.self, forKey: .filterName)
        self.filterSettings = try container.decode(JSONValue.self, forKey: .filterSettings)
        self.overlay = try container.decodeIfPresent(Bool.self, forKey: .overlay)
    }
}

extension OBSRequests.CreateSceneItem: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sceneName, forKey: .sceneName)
        try container.encode(sourceName, forKey: .sourceName)
        try container.encodeIfPresent(sceneItemEnabled, forKey: .sceneItemEnabled)
    }
}

extension OBSRequests.CreateSceneItem: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sceneName = try container.decode(String.self, forKey: .sceneName)
        self.sourceName = try container.decode(String.self, forKey: .sourceName)
        self.sceneItemEnabled = try container.decodeIfPresent(Bool.self, forKey: .sceneItemEnabled)
    }
}

extension OBSRequests.DuplicateSceneItem: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sceneName, forKey: .sceneName)
        try container.encode(sceneItemId, forKey: .sceneItemId)
        try container.encodeIfPresent(destinationSceneName, forKey: .destinationSceneName)
    }
}

extension OBSRequests.DuplicateSceneItem: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sceneName = try container.decode(String.self, forKey: .sceneName)
        self.sceneItemId = try container.decode(Int.self, forKey: .sceneItemId)
        self.destinationSceneName = try container.decodeIfPresent(String.self, forKey: .destinationSceneName)
    }
}

extension OBSRequests.SetInputSettings: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(inputName, forKey: .inputName)
        try container.encode(inputSettings, forKey: .inputSettings)
        try container.encodeIfPresent(overlay, forKey: .overlay)
    }
}

extension OBSRequests.SetInputSettings: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.inputName = try container.decode(String.self, forKey: .inputName)
        self.inputSettings = try container.decode(JSONValue.self, forKey: .inputSettings)
        self.overlay = try container.decodeIfPresent(Bool.self, forKey: .overlay)
    }
}

extension OBSRequests.GetSourceScreenshot: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sourceName, forKey: .sourceName)
        try container.encode(imageFormat, forKey: .imageFormat)
        try container.encodeIfPresent(imageWidth, forKey: .imageWidth)
        try container.encodeIfPresent(imageHeight, forKey: .imageHeight)
        try container.encodeIfPresent(imageCompressionQuality, forKey: .imageCompressionQuality)
    }
}

extension OBSRequests.GetSourceScreenshot: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sourceName = try container.decode(String.self, forKey: .sourceName)
        self.imageFormat = try container.decode(String.self, forKey: .imageFormat)
        self.imageWidth = try container.decodeIfPresent(Int.self, forKey: .imageWidth)
        self.imageHeight = try container.decodeIfPresent(Int.self, forKey: .imageHeight)
        self.imageCompressionQuality = try container.decodeIfPresent(Int.self, forKey: .imageCompressionQuality)
    }
}

extension OBSRequests.SetInputVolume: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(inputName, forKey: .inputName)
        try container.encodeIfPresent(inputVolumeMul, forKey: .inputVolumeMul)
        try container.encodeIfPresent(inputVolumeDb, forKey: .inputVolumeDb)
    }
}

extension OBSRequests.SetInputVolume: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.inputName = try container.decode(String.self, forKey: .inputName)
        self.inputVolumeMul = try container.decodeIfPresent(Int.self, forKey: .inputVolumeMul)
        self.inputVolumeDb = try container.decodeIfPresent(Int.self, forKey: .inputVolumeDb)
    }
}

extension OBSRequests.GetSceneItemId: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sceneName, forKey: .sceneName)
        try container.encode(sourceName, forKey: .sourceName)
        try container.encodeIfPresent(searchOffset, forKey: .searchOffset)
    }
}

extension OBSRequests.GetSceneItemId: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sceneName = try container.decode(String.self, forKey: .sceneName)
        self.sourceName = try container.decode(String.self, forKey: .sourceName)
        self.searchOffset = try container.decodeIfPresent(Int.self, forKey: .searchOffset)
    }
}

extension OBSRequests.SaveSourceScreenshot: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sourceName, forKey: .sourceName)
        try container.encode(imageFormat, forKey: .imageFormat)
        try container.encode(imageFilePath, forKey: .imageFilePath)
        try container.encodeIfPresent(imageWidth, forKey: .imageWidth)
        try container.encodeIfPresent(imageHeight, forKey: .imageHeight)
        try container.encodeIfPresent(imageCompressionQuality, forKey: .imageCompressionQuality)
    }
}

extension OBSRequests.SaveSourceScreenshot: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sourceName = try container.decode(String.self, forKey: .sourceName)
        self.imageFormat = try container.decode(String.self, forKey: .imageFormat)
        self.imageFilePath = try container.decode(String.self, forKey: .imageFilePath)
        self.imageWidth = try container.decodeIfPresent(Int.self, forKey: .imageWidth)
        self.imageHeight = try container.decodeIfPresent(Int.self, forKey: .imageHeight)
        self.imageCompressionQuality = try container.decodeIfPresent(Int.self, forKey: .imageCompressionQuality)
    }
}

extension OBSRequests.SetTBarPosition: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(position, forKey: .position)
        try container.encodeIfPresent(release, forKey: .release)
    }
}

extension OBSRequests.SetTBarPosition: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.position = try container.decode(Float.self, forKey: .position)
        self.release = try container.decodeIfPresent(Bool.self, forKey: .release)
    }
}

extension OBSRequests.CreateInput: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sceneName, forKey: .sceneName)
        try container.encode(inputName, forKey: .inputName)
        try container.encode(inputKind, forKey: .inputKind)
        try container.encodeIfPresent(inputSettings, forKey: .inputSettings)
        try container.encodeIfPresent(sceneItemEnabled, forKey: .sceneItemEnabled)
    }
}

extension OBSRequests.CreateInput: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sceneName = try container.decode(String.self, forKey: .sceneName)
        self.inputName = try container.decode(String.self, forKey: .inputName)
        self.inputKind = try container.decode(String.self, forKey: .inputKind)
        self.inputSettings = try container.decodeIfPresent(JSONValue.self, forKey: .inputSettings)
        self.sceneItemEnabled = try container.decodeIfPresent(Bool.self, forKey: .sceneItemEnabled)
    }
}

extension OBSRequests.SetVideoSettings: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(fpsNumerator, forKey: .fpsNumerator)
        try container.encodeIfPresent(fpsDenominator, forKey: .fpsDenominator)
        try container.encodeIfPresent(baseWidth, forKey: .baseWidth)
        try container.encodeIfPresent(baseHeight, forKey: .baseHeight)
        try container.encodeIfPresent(outputWidth, forKey: .outputWidth)
        try container.encodeIfPresent(outputHeight, forKey: .outputHeight)
    }
}

extension OBSRequests.SetVideoSettings: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.fpsNumerator = try container.decodeIfPresent(Int.self, forKey: .fpsNumerator)
        self.fpsDenominator = try container.decodeIfPresent(Int.self, forKey: .fpsDenominator)
        self.baseWidth = try container.decodeIfPresent(Int.self, forKey: .baseWidth)
        self.baseHeight = try container.decodeIfPresent(Int.self, forKey: .baseHeight)
        self.outputWidth = try container.decodeIfPresent(Int.self, forKey: .outputWidth)
        self.outputHeight = try container.decodeIfPresent(Int.self, forKey: .outputHeight)
    }
}

extension OBSRequests.OpenVideoMixProjector: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(videoMixType, forKey: .videoMixType)
        try container.encodeIfPresent(monitorIndex, forKey: .monitorIndex)
        try container.encodeIfPresent(projectorGeometry, forKey: .projectorGeometry)
    }
}

extension OBSRequests.OpenVideoMixProjector: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.videoMixType = try container.decode(String.self, forKey: .videoMixType)
        self.monitorIndex = try container.decodeIfPresent(Int.self, forKey: .monitorIndex)
        self.projectorGeometry = try container.decodeIfPresent(String.self, forKey: .projectorGeometry)
    }
}

extension OBSRequests.OpenSourceProjector: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(sourceName, forKey: .sourceName)
        try container.encodeIfPresent(monitorIndex, forKey: .monitorIndex)
        try container.encodeIfPresent(projectorGeometry, forKey: .projectorGeometry)
    }
}

extension OBSRequests.OpenSourceProjector: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.sourceName = try container.decode(String.self, forKey: .sourceName)
        self.monitorIndex = try container.decodeIfPresent(Int.self, forKey: .monitorIndex)
        self.projectorGeometry = try container.decodeIfPresent(String.self, forKey: .projectorGeometry)
    }
}

extension OBSRequests.CallVendorRequest: Encodable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(vendorName, forKey: .vendorName)
        try container.encode(requestType, forKey: .requestType)
        try container.encodeIfPresent(requestData, forKey: .requestData)
    }
}

extension OBSRequests.CallVendorRequest: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.vendorName = try container.decode(String.self, forKey: .vendorName)
        self.requestType = try container.decode(String.self, forKey: .requestType)
        self.requestData = try container.decodeIfPresent(JSONValue.self, forKey: .requestData)
    }
}

// MARK: - Events

public enum OBSEvents {
    /// The current scene collection has begun changing.
    /// - Note: We recommend using this event to trigger a pause of all polling requests, as performing any requests during a
    /// scene collection change is considered undefined behavior and can cause crashes!
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentSceneCollectionChanging: OBSEvent {
        /// Name of the current scene collection
        public var sceneCollectionName: String

        public init(sceneCollectionName: String) {
            self.sceneCollectionName = sceneCollectionName
        }
    }

    /// The current scene collection has changed.
    /// - Note: If polling has been paused during `CurrentSceneCollectionChanging`, this is the que to restart polling.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentSceneCollectionChanged: OBSEvent {
        /// Name of the new scene collection
        public var sceneCollectionName: String

        public init(sceneCollectionName: String) {
            self.sceneCollectionName = sceneCollectionName
        }
    }

    /// The scene collection list has changed.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneCollectionListChanged: OBSEvent {
        /// Updated list of scene collections
        public var sceneCollections: [String]

        public init(sceneCollections: [String]) {
            self.sceneCollections = sceneCollections
        }
    }

    /// The current profile has begun changing.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentProfileChanging: OBSEvent {
        /// Name of the current profile
        public var profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }
    }

    /// The current profile has changed.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentProfileChanged: OBSEvent {
        /// Name of the new profile
        public var profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }
    }

    /// The profile list has changed.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ProfileListChanged: OBSEvent {
        /// Updated list of profiles
        public var profiles: [String]

        public init(profiles: [String]) {
            self.profiles = profiles
        }
    }

    /// A source's filter list has been reindexed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SourceFilterListReindexed: OBSEvent {
        /// Name of the source
        public var sourceName: String

        /// Array of filter objects
        public var filters: [JSONValue]

        public init(sourceName: String, filters: [JSONValue]) {
            self.sourceName = sourceName
            self.filters = filters
        }
    }

    /// A filter has been added to a source.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SourceFilterCreated: OBSEvent {
        /// Name of the source the filter was added to
        public var sourceName: String

        /// Name of the filter
        public var filterName: String

        /// The kind of the filter
        public var filterKind: String

        /// Index position of the filter
        public var filterIndex: Int

        /// The settings configured to the filter when it was created
        public var filterSettings: JSONValue

        /// The default settings for the filter
        public var defaultFilterSettings: JSONValue

        public init(sourceName: String, filterName: String, filterKind: String, filterIndex: Int, filterSettings: JSONValue, defaultFilterSettings: JSONValue) {
            self.sourceName = sourceName
            self.filterName = filterName
            self.filterKind = filterKind
            self.filterIndex = filterIndex
            self.filterSettings = filterSettings
            self.defaultFilterSettings = defaultFilterSettings
        }
    }

    /// A filter has been removed from a source.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SourceFilterRemoved: OBSEvent {
        /// Name of the source the filter was on
        public var sourceName: String

        /// Name of the filter
        public var filterName: String

        public init(sourceName: String, filterName: String) {
            self.sourceName = sourceName
            self.filterName = filterName
        }
    }

    /// The name of a source filter has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SourceFilterNameChanged: OBSEvent {
        /// The source the filter is on
        public var sourceName: String

        /// Old name of the filter
        public var oldFilterName: String

        /// New name of the filter
        public var filterName: String

        public init(sourceName: String, oldFilterName: String, filterName: String) {
            self.sourceName = sourceName
            self.oldFilterName = oldFilterName
            self.filterName = filterName
        }
    }

    /// A source filter's enable state has changed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SourceFilterEnableStateChanged: OBSEvent {
        /// Name of the source the filter is on
        public var sourceName: String

        /// Name of the filter
        public var filterName: String

        /// Whether the filter is enabled
        public var filterEnabled: Bool

        public init(sourceName: String, filterName: String, filterEnabled: Bool) {
            self.sourceName = sourceName
            self.filterName = filterName
            self.filterEnabled = filterEnabled
        }
    }

    /// OBS has begun the shutdown process.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ExitStarted: OBSEvent {
        public init() {}
    }

    /// An input has been created.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputCreated: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// The kind of the input
        public var inputKind: String

        /// The unversioned kind of input (aka no `_v2` stuff)
        public var unversionedInputKind: String

        /// The settings configured to the input when it was created
        public var inputSettings: JSONValue

        /// The default settings for the input
        public var defaultInputSettings: JSONValue

        public init(inputName: String, inputKind: String, unversionedInputKind: String, inputSettings: JSONValue, defaultInputSettings: JSONValue) {
            self.inputName = inputName
            self.inputKind = inputKind
            self.unversionedInputKind = unversionedInputKind
            self.inputSettings = inputSettings
            self.defaultInputSettings = defaultInputSettings
        }
    }

    /// An input has been removed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputRemoved: OBSEvent {
        /// Name of the input
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }
    }

    /// The name of an input has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputNameChanged: OBSEvent {
        /// Old name of the input
        public var oldInputName: String

        /// New name of the input
        public var inputName: String

        public init(oldInputName: String, inputName: String) {
            self.oldInputName = oldInputName
            self.inputName = inputName
        }
    }

    /// An input's active state has changed.
    /// When an input is active, it means it's being shown by the program feed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputActiveStateChanged: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// Whether the input is active
        public var videoActive: Bool

        public init(inputName: String, videoActive: Bool) {
            self.inputName = inputName
            self.videoActive = videoActive
        }
    }

    /// An input's show state has changed.
    /// When an input is showing, it means it's being shown by the preview or a dialog.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputShowStateChanged: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// Whether the input is showing
        public var videoShowing: Bool

        public init(inputName: String, videoShowing: Bool) {
            self.inputName = inputName
            self.videoShowing = videoShowing
        }
    }

    /// An input's mute state has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputMuteStateChanged: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// Whether the input is muted
        public var inputMuted: Bool

        public init(inputName: String, inputMuted: Bool) {
            self.inputName = inputName
            self.inputMuted = inputMuted
        }
    }

    /// An input's volume level has changed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputVolumeChanged: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// New volume level in multimap
        public var inputVolumeMul: Int

        /// New volume level in dB
        public var inputVolumeDb: Int

        public init(inputName: String, inputVolumeMul: Int, inputVolumeDb: Int) {
            self.inputName = inputName
            self.inputVolumeMul = inputVolumeMul
            self.inputVolumeDb = inputVolumeDb
        }
    }

    /// The audio balance value of an input has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputAudioBalanceChanged: OBSEvent {
        /// Name of the affected input
        public var inputName: String

        /// New audio balance value of the input
        public var inputAudioBalance: Int

        public init(inputName: String, inputAudioBalance: Int) {
            self.inputName = inputName
            self.inputAudioBalance = inputAudioBalance
        }
    }

    /// The sync offset of an input has changed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputAudioSyncOffsetChanged: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// New sync offset in milliseconds
        public var inputAudioSyncOffset: Int

        public init(inputName: String, inputAudioSyncOffset: Int) {
            self.inputName = inputName
            self.inputAudioSyncOffset = inputAudioSyncOffset
        }
    }

    /// The audio tracks of an input have changed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputAudioTracksChanged: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// Object of audio tracks along with their associated enable states
        public var inputAudioTracks: JSONValue

        public init(inputName: String, inputAudioTracks: JSONValue) {
            self.inputName = inputName
            self.inputAudioTracks = inputAudioTracks
        }
    }

    /// The monitor type of an input has changed.
    /// Available types are:
    /// - `OBS_MONITORING_TYPE_NONE`
    /// - `OBS_MONITORING_TYPE_MONITOR_ONLY`
    /// - `OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT`
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputAudioMonitorTypeChanged: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// New monitor type of the input
        public var monitorType: String

        public init(inputName: String, monitorType: String) {
            self.inputName = inputName
            self.monitorType = monitorType
        }
    }

    /// A high-volume event providing volume levels of all active inputs every 50 milliseconds.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct InputVolumeMeters: OBSEvent {
        /// Array of active inputs with their associated volume levels
        public var inputs: [JSONValue]

        public init(inputs: [JSONValue]) {
            self.inputs = inputs
        }
    }

    /// A media input has started playing.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct MediaInputPlaybackStarted: OBSEvent {
        /// Name of the input
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }
    }

    /// A media input has finished playing.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct MediaInputPlaybackEnded: OBSEvent {
        /// Name of the input
        public var inputName: String

        public init(inputName: String) {
            self.inputName = inputName
        }
    }

    /// An action has been performed on an input.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct MediaInputActionTriggered: OBSEvent {
        /// Name of the input
        public var inputName: String

        /// Action performed on the input. See `ObsMediaInputAction` enum
        public var mediaAction: OBSEnums.MediaInputAction

        public init(inputName: String, mediaAction: OBSEnums.MediaInputAction) {
            self.inputName = inputName
            self.mediaAction = mediaAction
        }
    }

    /// The state of the stream output has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StreamStateChanged: OBSEvent {
        /// Whether the output is active
        public var outputActive: Bool

        /// The specific state of the output
        public var outputState: String

        public init(outputActive: Bool, outputState: String) {
            self.outputActive = outputActive
            self.outputState = outputState
        }
    }

    /// The state of the record output has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct RecordStateChanged: OBSEvent {
        /// Whether the output is active
        public var outputActive: Bool

        /// The specific state of the output
        public var outputState: String

        /// File name for the saved recording, if record stopped. `null` otherwise
        public var outputPath: String

        public init(outputActive: Bool, outputState: String, outputPath: String) {
            self.outputActive = outputActive
            self.outputState = outputState
            self.outputPath = outputPath
        }
    }

    /// The state of the replay buffer output has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ReplayBufferStateChanged: OBSEvent {
        /// Whether the output is active
        public var outputActive: Bool

        /// The specific state of the output
        public var outputState: String

        public init(outputActive: Bool, outputState: String) {
            self.outputActive = outputActive
            self.outputState = outputState
        }
    }

    /// The state of the virtualcam output has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct VirtualcamStateChanged: OBSEvent {
        /// Whether the output is active
        public var outputActive: Bool

        /// The specific state of the output
        public var outputState: String

        public init(outputActive: Bool, outputState: String) {
            self.outputActive = outputActive
            self.outputState = outputState
        }
    }

    /// The replay buffer has been saved.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct ReplayBufferSaved: OBSEvent {
        /// Path of the saved replay file
        public var savedReplayPath: String

        public init(savedReplayPath: String) {
            self.savedReplayPath = savedReplayPath
        }
    }

    /// A scene item has been created.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneItemCreated: OBSEvent {
        /// Name of the scene the item was added to
        public var sceneName: String

        /// Name of the underlying source (input/scene)
        public var sourceName: String

        /// Numeric ID of the scene item
        public var sceneItemId: Int

        /// Index position of the item
        public var sceneItemIndex: Int

        public init(sceneName: String, sourceName: String, sceneItemId: Int, sceneItemIndex: Int) {
            self.sceneName = sceneName
            self.sourceName = sourceName
            self.sceneItemId = sceneItemId
            self.sceneItemIndex = sceneItemIndex
        }
    }

    /// A scene item has been removed.
    /// This event is not emitted when the scene the item is in is removed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneItemRemoved: OBSEvent {
        /// Name of the scene the item was removed from
        public var sceneName: String

        /// Name of the underlying source (input/scene)
        public var sourceName: String

        /// Numeric ID of the scene item
        public var sceneItemId: Int

        public init(sceneName: String, sourceName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sourceName = sourceName
            self.sceneItemId = sceneItemId
        }
    }

    /// A scene's item list has been reindexed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneItemListReindexed: OBSEvent {
        /// Name of the scene
        public var sceneName: String

        /// Array of scene item objects
        public var sceneItems: [JSONValue]

        public init(sceneName: String, sceneItems: [JSONValue]) {
            self.sceneName = sceneName
            self.sceneItems = sceneItems
        }
    }

    /// A scene item's enable state has changed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneItemEnableStateChanged: OBSEvent {
        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        public var sceneItemId: Int

        /// Whether the scene item is enabled (visible)
        public var sceneItemEnabled: Bool

        public init(sceneName: String, sceneItemId: Int, sceneItemEnabled: Bool) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemEnabled = sceneItemEnabled
        }
    }

    /// A scene item's lock state has changed.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneItemLockStateChanged: OBSEvent {
        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        public var sceneItemId: Int

        /// Whether the scene item is locked
        public var sceneItemLocked: Bool

        public init(sceneName: String, sceneItemId: Int, sceneItemLocked: Bool) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemLocked = sceneItemLocked
        }
    }

    /// A scene item has been selected in the Ui.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneItemSelected: OBSEvent {
        /// Name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        public var sceneItemId: Int

        public init(sceneName: String, sceneItemId: Int) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
        }
    }

    /// The transform/crop of a scene item has changed.
    /// - Complexity: `4/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneItemTransformChanged: OBSEvent {
        /// The name of the scene the item is in
        public var sceneName: String

        /// Numeric ID of the scene item
        public var sceneItemId: Int

        /// New transform/crop info of the scene item
        public var sceneItemTransform: JSONValue

        public init(sceneName: String, sceneItemId: Int, sceneItemTransform: JSONValue) {
            self.sceneName = sceneName
            self.sceneItemId = sceneItemId
            self.sceneItemTransform = sceneItemTransform
        }
    }

    /// A new scene has been created.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneCreated: OBSEvent {
        /// Name of the new scene
        public var sceneName: String

        /// Whether the new scene is a group
        public var isGroup: Bool

        public init(sceneName: String, isGroup: Bool) {
            self.sceneName = sceneName
            self.isGroup = isGroup
        }
    }

    /// A scene has been removed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneRemoved: OBSEvent {
        /// Name of the removed scene
        public var sceneName: String

        /// Whether the scene was a group
        public var isGroup: Bool

        public init(sceneName: String, isGroup: Bool) {
            self.sceneName = sceneName
            self.isGroup = isGroup
        }
    }

    /// The name of a scene has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneNameChanged: OBSEvent {
        /// Old name of the scene
        public var oldSceneName: String

        /// New name of the scene
        public var sceneName: String

        public init(oldSceneName: String, sceneName: String) {
            self.oldSceneName = oldSceneName
            self.sceneName = sceneName
        }
    }

    /// The current program scene has changed.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentProgramSceneChanged: OBSEvent {
        /// Name of the scene that was switched to
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }
    }

    /// The current preview scene has changed.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentPreviewSceneChanged: OBSEvent {
        /// Name of the scene that was switched to
        public var sceneName: String

        public init(sceneName: String) {
            self.sceneName = sceneName
        }
    }

    /// The list of scenes has changed.
    /// TODO: Make OBS fire this event when scenes are reordered.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneListChanged: OBSEvent {
        /// Updated array of scenes
        public var scenes: [JSONValue]

        public init(scenes: [JSONValue]) {
            self.scenes = scenes
        }
    }

    /// The current scene transition has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentSceneTransitionChanged: OBSEvent {
        /// Name of the new transition
        public var transitionName: String

        public init(transitionName: String) {
            self.transitionName = transitionName
        }
    }

    /// The current scene transition duration has changed.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct CurrentSceneTransitionDurationChanged: OBSEvent {
        /// Transition duration in milliseconds
        public var transitionDuration: Int

        public init(transitionDuration: Int) {
            self.transitionDuration = transitionDuration
        }
    }

    /// A scene transition has started.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneTransitionStarted: OBSEvent {
        /// Scene transition name
        public var transitionName: String

        public init(transitionName: String) {
            self.transitionName = transitionName
        }
    }

    /// A scene transition has completed fully.
    /// - Note: Does not appear to trigger when the transition is interrupted by the user.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneTransitionEnded: OBSEvent {
        /// Scene transition name
        public var transitionName: String

        public init(transitionName: String) {
            self.transitionName = transitionName
        }
    }

    /// A scene transition's video has completed fully.
    /// Useful for stinger transitions to tell when the video *actually* ends.
    /// `SceneTransitionEnded` only signifies the cut point, not the completion of transition playback.
    /// - Note: Appears to be called by every transition, regardless of relevance.
    /// - Complexity: `2/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct SceneTransitionVideoEnded: OBSEvent {
        /// Scene transition name
        public var transitionName: String

        public init(transitionName: String) {
            self.transitionName = transitionName
        }
    }

    /// Studio mode has been enabled or disabled.
    /// - Complexity: `1/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct StudioModeStateChanged: OBSEvent {
        /// True == Enabled, False == Disabled
        public var studioModeEnabled: Bool

        public init(studioModeEnabled: Bool) {
            self.studioModeEnabled = studioModeEnabled
        }
    }

    /// An event has been emitted from a vendor.
    /// A vendor is a unique name registered by a third-party plugin or script, which allows for custom requests and events to be added to obs-websocket.
    /// If a plugin or script implements vendor requests or events, documentation is expected to be provided with them.
    /// - Complexity: `3/5`
    /// - Version: Latest Supported RPC Version - `1`
    /// - Since: Added in v5.0.0
    public struct VendorEvent: OBSEvent {
        /// Name of the vendor emitting the event
        public var vendorName: String

        /// Vendor-provided event typedef
        public var eventType: String

        /// Vendor-provided event data. {} if event does not provide any data
        public var eventData: JSONValue

        public init(vendorName: String, eventType: String, eventData: JSONValue) {
            self.vendorName = vendorName
            self.eventType = eventType
            self.eventData = eventData
        }
    }

    public enum AllTypes: String, Codable {
        case CurrentSceneCollectionChanging
        case CurrentSceneCollectionChanged
        case SceneCollectionListChanged
        case CurrentProfileChanging
        case CurrentProfileChanged
        case ProfileListChanged
        case SourceFilterListReindexed
        case SourceFilterCreated
        case SourceFilterRemoved
        case SourceFilterNameChanged
        case SourceFilterEnableStateChanged
        case ExitStarted
        case InputCreated
        case InputRemoved
        case InputNameChanged
        case InputActiveStateChanged
        case InputShowStateChanged
        case InputMuteStateChanged
        case InputVolumeChanged
        case InputAudioBalanceChanged
        case InputAudioSyncOffsetChanged
        case InputAudioTracksChanged
        case InputAudioMonitorTypeChanged
        case InputVolumeMeters
        case MediaInputPlaybackStarted
        case MediaInputPlaybackEnded
        case MediaInputActionTriggered
        case StreamStateChanged
        case RecordStateChanged
        case ReplayBufferStateChanged
        case VirtualcamStateChanged
        case ReplayBufferSaved
        case SceneItemCreated
        case SceneItemRemoved
        case SceneItemListReindexed
        case SceneItemEnableStateChanged
        case SceneItemLockStateChanged
        case SceneItemSelected
        case SceneItemTransformChanged
        case SceneCreated
        case SceneRemoved
        case SceneNameChanged
        case CurrentProgramSceneChanged
        case CurrentPreviewSceneChanged
        case SceneListChanged
        case CurrentSceneTransitionChanged
        case CurrentSceneTransitionDurationChanged
        case SceneTransitionStarted
        case SceneTransitionEnded
        case SceneTransitionVideoEnded
        case StudioModeStateChanged
        case VendorEvent
        
        public static func event(ofType type: AllTypes, from eventData: JSONValue) throws -> OBSEvent? {
            switch type {
            case .CurrentSceneCollectionChanging:
                return try eventData.toCodable(OBSEvents.CurrentSceneCollectionChanging.self)
            case .CurrentSceneCollectionChanged:
                return try eventData.toCodable(OBSEvents.CurrentSceneCollectionChanged.self)
            case .SceneCollectionListChanged:
                return try eventData.toCodable(OBSEvents.SceneCollectionListChanged.self)
            case .CurrentProfileChanging:
                return try eventData.toCodable(OBSEvents.CurrentProfileChanging.self)
            case .CurrentProfileChanged:
                return try eventData.toCodable(OBSEvents.CurrentProfileChanged.self)
            case .ProfileListChanged:
                return try eventData.toCodable(OBSEvents.ProfileListChanged.self)
            case .SourceFilterListReindexed:
                return try eventData.toCodable(OBSEvents.SourceFilterListReindexed.self)
            case .SourceFilterCreated:
                return try eventData.toCodable(OBSEvents.SourceFilterCreated.self)
            case .SourceFilterRemoved:
                return try eventData.toCodable(OBSEvents.SourceFilterRemoved.self)
            case .SourceFilterNameChanged:
                return try eventData.toCodable(OBSEvents.SourceFilterNameChanged.self)
            case .SourceFilterEnableStateChanged:
                return try eventData.toCodable(OBSEvents.SourceFilterEnableStateChanged.self)
            case .ExitStarted:
                return try eventData.toCodable(OBSEvents.ExitStarted.self)
            case .InputCreated:
                return try eventData.toCodable(OBSEvents.InputCreated.self)
            case .InputRemoved:
                return try eventData.toCodable(OBSEvents.InputRemoved.self)
            case .InputNameChanged:
                return try eventData.toCodable(OBSEvents.InputNameChanged.self)
            case .InputActiveStateChanged:
                return try eventData.toCodable(OBSEvents.InputActiveStateChanged.self)
            case .InputShowStateChanged:
                return try eventData.toCodable(OBSEvents.InputShowStateChanged.self)
            case .InputMuteStateChanged:
                return try eventData.toCodable(OBSEvents.InputMuteStateChanged.self)
            case .InputVolumeChanged:
                return try eventData.toCodable(OBSEvents.InputVolumeChanged.self)
            case .InputAudioBalanceChanged:
                return try eventData.toCodable(OBSEvents.InputAudioBalanceChanged.self)
            case .InputAudioSyncOffsetChanged:
                return try eventData.toCodable(OBSEvents.InputAudioSyncOffsetChanged.self)
            case .InputAudioTracksChanged:
                return try eventData.toCodable(OBSEvents.InputAudioTracksChanged.self)
            case .InputAudioMonitorTypeChanged:
                return try eventData.toCodable(OBSEvents.InputAudioMonitorTypeChanged.self)
            case .InputVolumeMeters:
                return try eventData.toCodable(OBSEvents.InputVolumeMeters.self)
            case .MediaInputPlaybackStarted:
                return try eventData.toCodable(OBSEvents.MediaInputPlaybackStarted.self)
            case .MediaInputPlaybackEnded:
                return try eventData.toCodable(OBSEvents.MediaInputPlaybackEnded.self)
            case .MediaInputActionTriggered:
                return try eventData.toCodable(OBSEvents.MediaInputActionTriggered.self)
            case .StreamStateChanged:
                return try eventData.toCodable(OBSEvents.StreamStateChanged.self)
            case .RecordStateChanged:
                return try eventData.toCodable(OBSEvents.RecordStateChanged.self)
            case .ReplayBufferStateChanged:
                return try eventData.toCodable(OBSEvents.ReplayBufferStateChanged.self)
            case .VirtualcamStateChanged:
                return try eventData.toCodable(OBSEvents.VirtualcamStateChanged.self)
            case .ReplayBufferSaved:
                return try eventData.toCodable(OBSEvents.ReplayBufferSaved.self)
            case .SceneItemCreated:
                return try eventData.toCodable(OBSEvents.SceneItemCreated.self)
            case .SceneItemRemoved:
                return try eventData.toCodable(OBSEvents.SceneItemRemoved.self)
            case .SceneItemListReindexed:
                return try eventData.toCodable(OBSEvents.SceneItemListReindexed.self)
            case .SceneItemEnableStateChanged:
                return try eventData.toCodable(OBSEvents.SceneItemEnableStateChanged.self)
            case .SceneItemLockStateChanged:
                return try eventData.toCodable(OBSEvents.SceneItemLockStateChanged.self)
            case .SceneItemSelected:
                return try eventData.toCodable(OBSEvents.SceneItemSelected.self)
            case .SceneItemTransformChanged:
                return try eventData.toCodable(OBSEvents.SceneItemTransformChanged.self)
            case .SceneCreated:
                return try eventData.toCodable(OBSEvents.SceneCreated.self)
            case .SceneRemoved:
                return try eventData.toCodable(OBSEvents.SceneRemoved.self)
            case .SceneNameChanged:
                return try eventData.toCodable(OBSEvents.SceneNameChanged.self)
            case .CurrentProgramSceneChanged:
                return try eventData.toCodable(OBSEvents.CurrentProgramSceneChanged.self)
            case .CurrentPreviewSceneChanged:
                return try eventData.toCodable(OBSEvents.CurrentPreviewSceneChanged.self)
            case .SceneListChanged:
                return try eventData.toCodable(OBSEvents.SceneListChanged.self)
            case .CurrentSceneTransitionChanged:
                return try eventData.toCodable(OBSEvents.CurrentSceneTransitionChanged.self)
            case .CurrentSceneTransitionDurationChanged:
                return try eventData.toCodable(OBSEvents.CurrentSceneTransitionDurationChanged.self)
            case .SceneTransitionStarted:
                return try eventData.toCodable(OBSEvents.SceneTransitionStarted.self)
            case .SceneTransitionEnded:
                return try eventData.toCodable(OBSEvents.SceneTransitionEnded.self)
            case .SceneTransitionVideoEnded:
                return try eventData.toCodable(OBSEvents.SceneTransitionVideoEnded.self)
            case .StudioModeStateChanged:
                return try eventData.toCodable(OBSEvents.StudioModeStateChanged.self)
            case .VendorEvent:
                return try eventData.toCodable(OBSEvents.VendorEvent.self)
    }
        }
    }
}
